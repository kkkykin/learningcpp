#+PROPERTY: header-args:cpp :results output :includes <iostream> :flags -ggdb -pedantic-errors -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion -Wshadow -Werror -std=c++2b

* Basic
** Initialization
https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/

Prefer list or value initialization.

#+begin_src cpp
int a;         // no initializer                            (default initialization)
int b = 5;     // initial value after equals sign           (copy initialization)
int c( 6 );    // initial value in parenthesis              (direct initialization)

// List initialization methods                              (C++11) (preferred)
int d { 7 };   // initial value in braces                   (direct list initialization)
int e = { 8 }; // initial value in braces after equals sign (copy list initialization)
int f {};      // initializer is empty braces               (value initialization)
#+end_src

*** multiple init
#+begin_src cpp
int a = 5, b = 6;          // copy initialization
int c( 7 ), d( 8 );        // direct initialization
int e { 9 }, f { 10 };     // direct brace initialization
int g = { 9 }, h = { 10 }; // copy brace initialization
int i {}, j {};            // value initialization
#+end_src

use [[maybe_unused]​] attribute to avoid error, via abbrev.

** iostream
Prefer \n over std::endl when outputting text to the console.


* Function and File
** Return value
If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.
#+begin_src cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
#+end_src

** Comment unused function parameter
When a function parameter exists but is not used in the body of the function, do not give it a name. You can optionally put a name inside a comment.
#+begin_src cpp
void doSomething(int /*count*/)
{
}
#+end_src

** Define variable
Define your local variables as close to their first use as reasonable.

** Preprocessor
The entire process of preprocessing, compiling, and linking is called translation.

Preprocessor doesn’t understand C++ concepts.

Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one file do not have any impact on other files (unless they are #included into another file).


** Header
Source files should #include their paired header file (if one exists).

Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.

Use the standard library header files without the .h extension. User-defined headers should still use a .h extension.

Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

*** #include order
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

That way, if one of your user-defined headers is missing an #include for a 3rd party library or standard library header, it’s more likely to cause a compile error so you can fix it.

** Header Guard
Beware two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\config.h and directoryB\config.h).

** Design and Implementation

*** Design step
**** Define goal
It is often useful to express this as a user-facing outcome. For example:

1. Allow the user to organize a list of names and associated phone numbers.
2. Generate randomized dungeons that will produce interesting looking caverns.
3. Generate a list of stock recommendations for stocks that have high dividends.
4. Model how long it takes for a ball dropped off a tower to hit the ground.
**** Define requirements
Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc…), as well as the capabilities that the program must exhibit in order to meet the users’ needs. Note that your requirements should similarly be focused on the “what”, not the “how”. For example:

- Phone numbers should be saved, so they can be recalled later.
- The randomized dungeon should always contain a way to get from the entrance to an exit.
- The stock recommendations should leverage historical pricing data.
- The user should be able to enter the height of the tower.
- We need a testable version within 7 days.
- The program should produce results within 10 seconds of the user submitting their request.
- The program should crash in less than 0.1% of user sessions.
**** Define your tools, targets, and backup plan
- Defining what target architecture and/or OS your program will run on.
- Determining what set of tools you will be using.
- Determining whether you will write your program alone or as part of a team.
- Defining your testing/feedback/release strategy.
- Determining how you will back up your code.
**** Break hard problems down into easy problems
The top level task becomes main() (because it is the main problem you are trying to solve). The subitems become functions in the program.
**** Figure out the sequence of events
If we were writing a calculator, we might do things in this order:

1. Get first number from user
2. Get mathematical operation from user
3. Get second number from user
4. Calculate result
5. Print result

At this point, we’re ready for implementation.

*** Implementation
**** Outlining your main function
#+begin_src cpp
int main()
{
    // Get first number from user
//    getUserInput();

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Implement each function
1. Define the function prototype (inputs and outputs)
2. Write the function
3. Test the function
#+begin_src cpp
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Final testing
Once your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.

*** Words of advice when writing programs

**** Keep your programs simple to start
Often new programmers have a grand vision for all the things they want their program to do. “I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon”. If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress. Instead, make your first goal as simple as possible, something that is definitely within your reach. For example, “I want to be able to display a 2-dimensional field on the screen”.



**** Add features over time
Once you have your simple program working and working well, then you can add features to it. For example, once you can display your field, add a character who can walk around. Once you can walk around, add walls that can impede your progress. Once you have walls, build a simple town out of them. Once you have a town, add merchants. By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.

**** Focus on one area at a time
New programmers will often write the entire program in one pass. Then when they compile it for the first time, the compiler reports hundreds of errors. This can not only be intimidating, if your code doesn’t work, it may be hard to figure out why. Instead, write a piece of code, and then compile and test it immediately. If it doesn’t work, you’ll know exactly where the problem is, and it will be easy to fix. Once you are sure that the code works, move to the next piece and repeat. It may take longer to finish writing your code, but when you are done the whole thing should work, and you won’t have to spend twice as long trying to figure out why it doesn’t.

**** Don’t invest in perfecting early code
The first draft of a feature (or program) is rarely good. Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things. If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary. Instead, get your features minimally working and then move on. As you gain confidence in your solutions, apply successive layers of polish. Don’t aim for perfect -- non-trivial programs are never perfect, and there’s always something more that could be done to improve them. Get to “good enough” and move on.



**** Optimize for maintainability, not performance
There is a famous quote (by Donald Knuth) that says “premature optimization is the root of all evil”. New programmers often spend far too much time thinking about how to micro-optimize their code (e.g. trying to figure out which of 2 statements is faster). This rarely matters. Most performance benefits come from good program structure, using the right tools and capabilities for the problem at hand, and following best practices. Additional time should be used to improve the maintainability of your code. Find redundancy and remove it. Split up long functions into shorter ones. Replace awkward or hard to use code with something better. The end result will be code that is easier to improve and optimize later (after you’ve determined where optimization is actually needed) and fewer bugs.



* Debug
** Step
1. Find the root cause of the problem (usually the line of code that’s not working).
2. Ensure you understand why the issue is occurring.
3. Determine how you’ll fix the issue.
4. Repair the issue causing the problem.
5. Retest to ensure the problem has been fixed.
6. Retest to ensure no new problems have emerged.

** Tactic

*** std::cerr instead of std::cout when debugging
cerr is unbufferd.

*** Debug with preprocessor
#+begin_src cpp
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging, or define in header file

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
#+end_src

*** Logger
Such as spdlog or plog.

** Refactor
Ideally, a function should be less than ten lines. Functions that are less than five lines are even better.

Remember that the goal here is to maximize comprehension and maintainability, not to minimize function length -- abandoning best practices or using obscure coding techniques to save a line or two doesn’t do your code any favors.

** Defensive programming
Defensive programming is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code. These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).

** unit testing
#+begin_src cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void testadd()
{
	std::cout << "This function should print: 2 0 0 -2\n";
	std::cout << add(1, 1) << ' ';
	std::cout << add(-1, 1) << ' ';
	std::cout << add(1, -1) << ' ';
	std::cout << add(-1, -1) << ' ';
}

int main()
{
	testadd();

	return 0;
}
#+end_src

* Fundamental Data Type
** Int
#+begin_src cpp
short s;      // prefer "short" instead of "short int"
int i;
long l;       // prefer "long" instead of "long int"
long long ll; // prefer "long long" instead of "long long int"
signed short ss;
signed int si;
signed long sl;
signed long long sll;
#+end_src
Prefer the shorthand types that do not use the int suffix or signed prefix.

*** Signed integer range
$-(2^(n-1))$ to $2^(n-1)-1$

If outside the range, then overflow.

*** Unsigned integer
Avoid unsigned integer.

Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.

**** when should you use unsigned numbers?
First, unsigned numbers are preferred when dealing with bit manipulation (covered in chapter O -- that’s a capital ‘o’, not a ‘0’). They are also useful when well-defined wrap-around behavior is required (useful in some algorithms like encryption and random number generation).

Second, use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing. We’ll talk more about this in the lessons on arrays and array indexing.

Also note that if you’re developing for an embedded system (e.g. an Arduino) or some other processor/memory limited context, use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.

*** fixed-width-integers and size_t

**** integer choice

***** Prefer

Prefer int when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer) and the variable is short-lived (e.g. destroyed at the end of the function). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
Prefer std::int#_t when storing a quantity that needs a guaranteed range.
Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required.

***** Avoid

short and long integers -- use a fixed-width type instead.
Unsigned types for holding quantities.
The 8-bit fixed-width integer types.
The fast and least fixed-width types.
Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…

**** size_t
std::size_t is an alias for an implementation-defined unsigned integral type. It is used within the standard library to represent the byte-size or length of objects.

If you use std::size_t explicitly in your code, #include one of the headers that defines std::size_t (we recommend <cstddef>).
Using sizeof does not require a header (even though it return a value whose type is std::size_t).
** Float
Prefer: double > float > long float

#+begin_src cpp
int a { 5 };      // 5 means integer
double b { 5.0 }; // 5.0 is a floating point literal (no suffix means double type by default)
float c { 5.0f }; // 5.0 is a floating point literal, f suffix means float type

int d { 0 }       // 0 is an integer
double e { 0.0 }  // 0.0 is a double
#+end_src
Note that by default, floating point literals default to type double. An f suffix is used to denote a literal of type float.

Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.

*** Maybe auto scientific notation
#+begin_src cpp
std::cout << 9.87654321f << '\n';
std::cout << 987.654321f << '\n';
std::cout << 987654.321f << '\n';
std::cout << 9876543.21f << '\n';
std::cout << 0.0000987654321f << '\n';
#+end_src

*** default double if not suffix with 'f'
#+begin_src cpp :includes '(<iostream> <iomanip>)
std::cout << std::setprecision(17); // show 17 digits of precision
std::cout << 3.33333333333333333333333333333333333333f <<'\n'; // f suffix means float
std::cout << 3.33333333333333333333333333333333333333 << '\n'; // no suffix means double
#+end_src

*** Precision issues don’t just impact fractional numbers
#+begin_src cpp :includes '(<iostream> <iomanip>)
float f { 123456789.0f }; // f has 10 significant digits
std::cout << std::setprecision(9); // to show 9 digits in f
std::cout << f << '\n';
#+end_src

*** Be wary of using floating point numbers for financial or currency data.
#+begin_src cpp :includes '(<iostream> <iomanip>)
std::cout << std::setprecision(17);

double d1{ 1.0 };
std::cout << d1 << '\n';

double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0
std::cout << d2 << '\n';
#+end_src

*** NaN and Inf
Avoid division by 0.0 altogether, even if your compiler supports it.
#+begin_src cpp
double zero {0.0};
double posinf { 5.0 / zero }; // positive infinity
std::cout << posinf << '\n';

double neginf { -5.0 / zero }; // negative infinity
std::cout << neginf << '\n';

double nan { zero / zero }; // not a number (mathematically invalid)
std::cout << nan << '\n';
#+end_src

** Boolean
#+begin_src cpp
bool b1 { true };
bool b2 { false };
b1 = false;
bool b3 {}; // default initialize to false
bool b1 { !true }; // b1 will be initialized with the value false
bool b2 { !false }; // b2 will be initialized with the value true
#+end_src

*** Stored as integer
#+begin_src cpp
std::cout << true << '\n'; // true evaluates to 1
std::cout << !true << '\n'; // !true evaluates to 0

bool b {false};
std::cout << b << '\n'; // b is false, which evaluates to 0
std::cout << !b << '\n'; // !b is true, which evaluates to 1
#+end_src

*** Boolalpha
#+begin_src cpp
std::cout << true << '\n';
std::cout << false << '\n';

std::cout << std::boolalpha; // print bools as true or false
// std::cout << std::noboolalpha; // turn it back

std::cout << true << '\n';
std::cout << false << '\n';
#+end_src

*** Integer to Boolean conversion
#+begin_src cpp
bool bFalse { 0 }; // okay: initialized to false
bool bTrue  { 1 }; // okay: initialized to true
bool bNo    { 2 }; // error: narrowing conversions disallowed

std::cout << bFalse << bTrue << bNo << '\n';
#+end_src

but copy init works.
#+begin_src cpp
std::cout << std::boolalpha; // print bools as true or false

bool b1 = 4 ; // copy initialization allows implicit conversion from int to bool
std::cout << b1 << '\n';

bool b2 = 0 ; // copy initialization allows implicit conversion from int to bool
std::cout << b2 << '\n';
#+end_src

*** Inputting Boolean values
#+begin_src cpp :eval no
bool b{}; // default initialize to false
std::cout << "Enter a boolean value: ";
std::cin >> b;
std::cout << "You entered: " << b << '\n';
#+end_src

Only accept 0 or 1; if not enable 'std::boolalpha'.
Enabling std::boolalpha for input will only allow lower-cased false or true to be accepted. Variations with capital letters will not be accepted. 0 and 1 will also no longer be accepted.
#+begin_src cpp :eval no
bool b{};
std::cout << "Enter a boolean value: ";

// Allow the user to input 'true' or 'false' for boolean values
// This is case-sensitive, so True or TRUE will not work
std::cin >> std::boolalpha;
std::cin >> b;

// Let's also output bool values as `true` or `false`
std::cout << std::boolalpha;
std::cout << "You entered: " << b << '\n';
#+end_src

*** Return value
retrun true or false.
#+begin_src cpp :eval no :main no
// returns true if x and y are equal, false otherwise
bool isEqual(int x, int y)
{
    return x == y; // operator== returns true if x equals y, and false otherwise
}

int main()
{
    std::cout << "Enter an integer: ";
    int x{};
    std::cin >> x;

    std::cout << "Enter another integer: ";
    int y{};
    std::cin >> y;

    std::cout << std::boolalpha; // print bools as true or false

    std::cout << x << " and " << y << " are equal? ";
    std::cout << isEqual(x, y) << '\n'; // will return true or false
** Char
Avoid militarist literals (e.g. '56').
*** Other char type
wchar_t should be avoided in almost all cases (except when interfacing with the Windows API).

You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible.
*** Type Conversion and static_cast
Type conversion uses direct initialization to produce a new value of the target type from a value of a different type.

Prefer static_cast<type>(x)
* Constant and String
** Constant variable
Place const before the type (because it is more conventional to do so).
Don’t use const when passing by value.
Don’t use const when returning by value.
Prefer constant variables over object-like macros with substitution text.
** Literal
*** Type of literal
| Literal value        | Examples        | Default literal type | Note                                      |
|----------------------+-----------------+----------------------+-------------------------------------------|
| integer value        | 5, 0, -3        | int                  |                                           |
| boolean value        | true, false     | bool                 |                                           |
| floating point value | 1.2, 0.0, 3.4   | double (not float!)  |                                           |
| character            | ‘a’, ‘\n’       | char                 |                                           |
| C-style string       | “Hello, world!” | const char[14]       | see C-style string literals section below |
*** Literal suffixes
If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix. Here are some of the more common suffixes:
In most cases, suffixes aren’t needed (except for f).
| Data type      | Suffix                                 | Meaning                                   |
|----------------+----------------------------------------+-------------------------------------------|
| integral       | u or U                                 | unsigned int                              |
| integral       | l or L                                 | long                                      |
| integral       | ul, uL, Ul, UL, lu, lU, Lu, LU         | unsigned long                             |
| integral       | ll or LL                               | long long                                 |
| integral       | ull, uLL, Ull, ULL, llu, llU, LLu, LLU | unsigned long long                        |
| integral       | z or Z                                 | The signed version of std::size_t (C++23) |
| integral       | uz, uZ, Uz, UZ, zu, zU, Zu, ZU         | std::size_t (C++23)                       |
| floating point | f or F                                 | float                                     |
| floating point | l or L                                 | long double                               |
| string         | s                                      | std::string                               |
| string         | sv                                     | std::string_view                          |
Because lower-case L can look like numeric 1 in some fonts, some developers prefer to use upper-case literals. Others use lower case suffixes except for L.
*** String
C-style string literals are const objects that are created at the start of the program and are guaranteed to exist for the entirety of the program.
Unlike C-style string literals, std::string and std::string_view literals create temporary objects. These temporary objects must be used immediately, as they are destroyed at the end of the full expression in which they are created.
*** Magic number
A magic number is a literal (usually a number) that either has an unclear meaning or may need to be changed later.
Avoid magic numbers in your code (use constexpr variables instead).
** Number
| decimal | octal | hexdecimal | binary |
|---------+-------+------------+--------|
|       1 |    01 |        0x1 | 0b1    |
|      12 |   014 |        0xC | 0b1100 |

*** Seperator
#+begin_src cpp
int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
long value { 2'132'673'462 }; // much easier to read than 2132673462
int cin { 0b'1011'0010 };  // error: ' used before first digit of value
#+end_src

*** Output
#+begin_src cpp
int x { 12 };
std::cout << x << '\n'; // decimal (by default)
std::cout << std::hex << x << '\n'; // hexadecimal
std::cout << x << '\n'; // now hexadecimal
std::cout << std::oct << x << '\n'; // octal
std::cout << std::dec << x << '\n'; // return to decimal
std::cout << x << '\n'; // decimal
#+end_src
Note that once applied, the I/O manipulator remains set for future output until it is changed again.

binary
#+begin_src cpp :main no
#include <bitset> // for std::bitset
#include <iostream>

int main()
{
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it

	return 0;
}
#+end_src

**** Format and Print
#+begin_src cpp :main no
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} formats the argument as binary digits
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} formats the argument as 0b-prefixed binary digits

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, format/print two arguments (same as above) and a newline

    return 0;
}
#+end_src


** Constant expressions
The most common type of operators and functions that support compile-time evaluation include:

Arithmetic operators with operands that are compile-time constants (e.g. 1 + 2)
Constexpr and consteval functions (we’ll discuss these later in the chapter)

If the const variable has an integral type and a constant expression initializer, it is a compile-time constant.
#+begin_src cpp :main no
#include <iostream>

int getNumber()
{
    std::cout << "Enter a number: ";
    int y{};
    std::cin >> y;

    return y;
}

int main()
{
    // Non-const variables are always non-constants:
    int a { 5 };                 // 5 is a constant expression
    double b { 1.2 + 3.4 };      // 1.2 + 3.4 is a constant expression

    // Const integral variables with a constant expression initializer are compile-time constants:
    const int c { 5 };           // 5 is a constant expression
    const int d { c };           // c is a constant expression
    const long e { c + 2 };      // c + 2 is a constant expression

    // Other const variables are runtime constants:
    const int f { a };           // a is not a constant expression
    const int g { a + 1 };       // a + 1 is not a constant expression
    const int h { a + c };       // a + c is not a constant expression
    const int i { getNumber() }; // getNumber() is not a constant expression

    const double j { b };        // b is not a constant expression
    const double k { 1.2 };      // 1.2 is a constant expression

    return 0;
}
#+end_src

*** pros and cons
good for performance, but bad for debug.

** Constexpr variable
Any constant variable whose initializer is a constant expression should be declared as constexpr.

Any constant variable whose initializer is not a constant expression (making it a runtime constant) should be declared as const.
#+begin_src cpp
#include <iostream>

// The return value of a non-constexpr function is not a constant expression
int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
#+end_src

| Term                  | Definition                                                                                                                                                        |
|-----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Compile-time constant | A value or non-modifiable object whose value must be known at compile time (e.g. literals and constexpr variables).                                               |
| Constexpr             | Keyword that declares variables as compile-time constants (and functions that can be evaluated at compile-time). Informally, shorthand for “constant expression”. |
| Constant expression   | An expression that contains only compile-time constants and operators/functions that support compile-time evaluation.                                             |
| Runtime expression    | An expression that is not a constant expression.                                                                                                                  |
| Runtime constant      | A value or non-modifiable object that is not a compile-time constant.                                                                                             |

** Ternary Operator
Parenthesize the entire conditional operation (including operands) when used in a compound expression.

For readability, consider parenthesizing the condition if it contains any operators (other than the function call operator).

*** Warning
The type of the second and third operand must match.
The compiler must be able to find a way to convert one or both of the second and third operands to matching types. The conversion rules the compiler uses are fairly complex and may yield surprising results in some cases.
#+begin_src cpp
std::cout << (true ? 1 : 2) << '\n';    // okay: both operands have matching type int

std::cout << (false ? 1 : 2.2) << '\n'; // okay: int value 1 converted to double

std::cout << (true ? -1 : 2u) << '\n';  // surprising result: -1 converted to unsigned int, result out of range
#+end_src

*** When should you use the conditional operator?
- Initializing an object with one of two values.
- Assigning one of two values to an object.
- Passing one of two values to a function.
- Returning one of two values from a function.
- Printing one of two values.

Prefer to avoid the conditional operator in complicated expressions.

** Inline function and variable
Avoid the use of the inline keyword unless you have a specific, compelling reason to do so (e.g. you’re defining those functions or variables in a header file).

*** The following are implicitly inline:

Functions defined inside a class, struct, or union type definition 
Constexpr / consteval functions.
Functions implicitly instantiated from function templates.

** Constexpr function
When a constexpr function evaluates at runtime, it evaluates just like a normal (non-constexpr) function would. In other words, the constexpr has no effect in this case.

All constexpr functions should be evaluatable at compile-time, as they will be required to do so in contexts that require a constant expression.

Always test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.

*** definition
Constexpr/consteval functions used in a single source file (.cpp) can be defined in the source file above where they are used.

Constexpr/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.

*** Recap
Marking a function as constexpr means it can be used in a constant expression. It does not mean “will evaluate at compile-time”.

A constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.

In contexts that do not require a constant expression, the compiler may choose whether to evaluate a constant expression (which may contain constexpr function calls) at compile-time or at runtime.

A runtime (non-constant) expression (which may contain constexpr function calls or non-constexpr function calls) will evaluate at runtime.

Unless you have a specific reason not to, a function that can evaluate as part of a constant expression should be made constexpr.

A function that cannot be evaluated as part of a constant expression should not be marked as constexpr.

*** Consteval
Use consteval if you have a function that must evaluate at compile-time for some reason (e.g. because it does something that can only be done at compile time).

Using consteval to make constexpr execute at compile-time.
#+begin_src cpp :main no
#include <iostream>

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x > y ? x : y);
}

int main()
{
    std::cout << greater(5, 6) << '\n';                  // may or may not execute at compile-time
    std::cout << compileTimeEval(greater(5, 6)) << '\n'; // will execute at compile-time

    int x { 5 };
    std::cout << greater(x, 6) << '\n';                  // we can still call the constexpr version at runtime if we wish

    return 0;
}
#+end_src


** String
If using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace. This needs to be done for each std::getline() call, as std::ws is not preserved across calls.

When extracting to a variable, the extraction operator (>>) ignores leading whitespace. It stops extracting when encountering non-leading whitespace.

std::getline() does not ignore leading whitespace. If you want it to ignore leading whitespace, pass std::cin >> std::ws as the first argument. It stops extracting when encountering a newline.
#+begin_src cpp
std::cout << "Enter your full name: ";
std::string name{};
std::getline(std::cin >> std::ws, name); // read a full line of text into name

std::cout << "Enter your favorite color: ";
std::string color{};
std::getline(std::cin >> std::ws, color); // read a full line of text into color

std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';
#+end_src

*** Length
Beware size type.
#+begin_src cpp
std::string name{ "Alex" };
std::cout << name << " has " << name.length() << " characters\n";
std::cout << name << " has " << std::ssize(name) << " characters\n";
int len { static_cast<int>(std::ssize(name)) };
#+end_src

*** Expensive string
Do not pass std::string by value, as it makes an expensive copy.

However, as a rule of thumb, it is okay to return a std::string by value when the expression of the return statement resolves to any of the following:

- A local variable of type std::string.
- A std::string that has been returned by value from another function call or operator.
- A std::string temporary that is created as part of the return statement.


*** Literal string
#+begin_src cpp :includes '(<string> <iostream>)
using namespace std::string_literals; // easy access to the s suffix

std::cout << "foo\n";   // no suffix is a C-style string literal
std::cout << "goo\n"s;  // s suffix is a std::string literal
#+end_src

"Hello"s resolves to std::string { "Hello", 5 } which creates a temporary std::string initialized with C-style string literal “Hello” (which has a length of 5, excluding the implicit null-terminator).

** String_view

Unlike std::string, std::string_view has full support for constexpr:

Prefer std::string_view over std::string when you need a read-only string, especially for function parameters.
*** Convert to String
#+begin_src cpp :main no
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str)
{
	std::cout << str << '\n';
}

int main()
{
	std::string_view sv{ "Hello, world!" };

	// printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string

	std::string s{ sv }; // okay: we can create std::string using std::string_view initializer
	printString(s);      // and call the function with the std::string

	printString(static_cast<std::string>(sv)); // okay: we can explicitly cast a std::string_view to a std::string

	return 0;
}
#+end_src
*** Literals string_view
#+begin_src cpp :main no
#include <iostream>
#include <string>      // for std::string
#include <string_view> // for std::string_view

int main()
{
    using namespace std::string_literals;      // access the s suffix
    using namespace std::string_view_literals; // access the sv suffix

    std::cout << "foo\n";   // no suffix is a C-style string literal
    std::cout << "goo\n"s;  // s suffix is a std::string literal
    std::cout << "moo\n"sv; // sv suffix is a std::string_view literal

    return 0;
}
#+end_src

** view
A view is dependent on the object being viewed. If the object being viewed is modified or destroyed while the view is still being used, unexpected or undefined behavior will result.
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string_view sv{};

{ // create a nested block
    std::string s{ "Hello, world!" }; // create a std::string local to this nested block
    sv = s; // sv is now viewing s
} // s is destroyed here, so sv is now viewing an invalid string

std::cout << sv << '\n'; // undefined behavior
#+end_src

Do not initialize a std::string_view with a std::string literal, as this will leave the std::string_view dangling.

It is okay to initialize a std::string_view with a C-style string literal or a std::string_view literal. It’s also okay to initialize a std::string_view with a C-style string object, a std::string object, or a std::string_view object, as long as that string object outlives the view.
#+begin_src cpp
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior
#+end_src

** Revalidate string_view
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior

sv = s;                    // revalidate sv: sv is now viewing s again
std::cout << sv << '\n';   // prints "Hello, universe!"
#+end_src

** returning std::string_view
If an argument is a temporary that is destroyed at the end of the full expression containing the function call, the returned std::string_view must be used immediately, as it will be left dangling after the temporary is destroyed.

** view modification function
The remove_prefix() member function removes characters from the left side of the view.
The remove_suffix() member function removes characters from the right side of the view.
#+begin_src cpp
#include <iostream>
#include <string_view>

int main()
{
	std::string_view str{ "Peach" };
	std::cout << str << '\n';

	// Remove 1 character from the left side of the view
	str.remove_prefix(1);
	std::cout << str << '\n';

	// Remove 2 characters from the right side of the view
	str.remove_suffix(2);
	std::cout << str << '\n';

	str = "Peach"; // reset the view
	std::cout << str << '\n';

	return 0;
}
#+end_src

** null-terminate
A C-style string literal and a std::string are always null-terminated.
A std::string_view may or may not be null-terminated.

Take care not to write any code that assumes a std::string_view is null terminated.
If you have a non-null-terminated std::string_view and you need a null-terminated string for some reason, convert the std::string_view into a std::string.

** When to use std::string vs std::string_view

*** Variables
**** Use a std::string variable when:

You need a string that you can modify.
You need to store user-inputted text.
You need to store the return value of a function that returns a std::string.

**** Use a std::string_view variable when:

You need read-only access to part or all of a string that already exists elsewhere and will not be modified or destroyed before use of the std::string_view is complete.
You need a symbolic constant for a C-style string.
You need to continue viewing the return value of a function that returns a C-style string or a non-dangling std::string_view.

*** Function parameters
**** Use a std::string function parameter when:

The function needs to modify the string passed in as an argument without affecting the caller. This is rare.
You are using language standard C++14 or older and aren’t comfortable using references yet.

**** Use a std::string_view function parameter when:

The function needs a read-only string.
The function needs to work with non-null-terminated strings.

*** Return types
**** Use a std::string return type when:

The return value is a std::string local variable or function parameter.
The return value is a function call or operator that returns a std::string by value.

**** Use a std::string_view return type when:

The function returns a C-style string literal or local std::string_view that has been initialized with a C-style string literal.
The function returns a std::string_view parameter.

** Some important about std::string and std::string_view
*** std::string
- Initializing and copying std::string is expensive, so avoid this as much as possible.
- Avoid passing std::string by value, as this makes a copy.
- If possible, avoid creating short-lived std::string objects.
- Modifying a std::string will invalidate any views to that string.
- It is okay to return a local std::string by value.
*** std::string_view
- std::string_view is typically used for passing string function parameters and returning string literals.
- Because C-style string literals exist for the entire program, it is always okay to set a std::string_view to a C-style string literal.
- When a string is destroyed, all views to that string are invalidated.
- Using an invalidated view (other than using assignment to revalidate the view) will cause undefined behavior.
- A std::string_view may or may not be null-terminated.
* Operators
** Operator precedence and associativity
Ensure that the expressions (or function calls) you write are not dependent on operand (or argument) evaluation order.
** Remainder and exponentiatio
Prefer to compare the result of the remainder operator (operator%) against 0 if possible.
** Increment/decrement operators, and side effects
Favor the prefix versions, as they are more performant and less likely to cause surprises.

Don’t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined.

One exception is for simple assignment expressions such as x = x + y (which is essentially equivalent to x += y).
** The comma operator
#+begin_src cpp
z = (a, b); // evaluate (a, b) first to get result of b, then assign that value to variable z.
z = a, b; // evaluates as "(z = a), b", so z gets assigned the value of a, and b is evaluated and discarded.
#+end_src
Avoid using the comma operator, except within for loops.
** Relational operators and floating point comparisons
Don’t add unnecessary == or != to boolean conditions. It makes them harder to read without offering any additional value.

*** Float
Comparing floating point values using any of the relational operators can be dangerous. This is because floating point values are not precise, and small rounding errors in the floating point operands may cause them to be slightly smaller or slightly larger than expected. And this can throw off the relational operators.

Avoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated.
It is safe to compare a floating point literal with a variable of the same type that has been initialized with a literal of the same type, so long as the number of significant digits in each literal does not exceed the minimum precision for that type. Float has a minimum precision of 6 significant digits, and double has a minimum precision of 15 significant digits.

It is generally not safe to compare floating point literals of different types.

**** approximatelyEqual
#+begin_src cpp :main no
// C++23 version
#include <algorithm> // for std::max
#include <cmath>     // for std::abs (constexpr in C++23)

// Return true if the difference between a and b is within epsilon percent of the larger of a and b
constexpr bool approximatelyEqualRel(double a, double b, double relEpsilon)
{
	return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

// Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b
constexpr bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)
{
    // Check if the numbers are really close -- needed when comparing numbers near zero.
    if (std::abs(a - b) <= absEpsilon)
        return true;

    // Otherwise fall back to Knuth's algorithm
    return approximatelyEqualRel(a, b, relEpsilon);
}
#+end_src

** Logical operators
*** De Morgan’s laws
!(x && y) is equivalent to !x || !y
!(x || y) is equivalent to !x && !y

*** XOR
#+begin_src cpp
if (a != b) ... // a XOR b, assuming a and b are bool
if (a != b != c) ... // a XOR b XOR c, assuming a, b, and c are bool
if (static_cast<bool>(a) != static_cast<bool>(b) != static_cast<bool>(c)) ... // a XOR b XOR c, for any type that can be converted to bool
if (!!a != !!b != !!c) // a XOR b XOR c, for any type that can be converted to bool
#+end_src

** Bit Manipulation
In some storage-intensive cases, maybe need bit manipulation. So i skip it.
* Bit Manipulation (optional chapter)
** Bit flags and bit manipulation via std::bitset
Bit manipulation is one of the few times when you should unambiguously use unsigned integers (or std::bitset).
*** Manipulating bits via std::bitset
std::bitset provides 4 key member functions that are useful for doing bit manipulation:
- test() allows us to query whether a bit is a 0 or 1.
- set() allows us to turn a bit on (this will do nothing if the bit is already on).
- reset() allows us to turn a bit off (this will do nothing if the bit is already off).
- flip() allows us to flip a bit value from a 0 to a 1 or vice versa.

#+begin_src cpp :main no
#include <bitset>
#include <iostream>

int main()
{
    std::bitset<8> bits{ 0b0000'0101 }; // we need 8 bits, start with bit pattern 0000 0101
    bits.set(3);   // set bit position 3 to 1 (now we have 0000 1101)
    bits.flip(4);  // flip bit 4 (now we have 0001 1101)
    bits.reset(4); // set bit 4 back to 0 (now we have 0000 1101)

    std::cout << "All the bits: " << bits<< '\n';
    std::cout << "Bit 3 has value: " << bits.test(3) << '\n';
    std::cout << "Bit 4 has value: " << bits.test(4) << '\n';

    return 0;
}
#+end_src
*** Querying std::bitset
- size() returns the number of bits in the bitset.
- count() returns the number of bits in the bitset that are set to true.
- all() returns a Boolean indicating whether all bits are set to true.
- any() returns a Boolean indicating whether any bits are set to true.
- none() returns a Boolean indicating whether no bits are set to true.
** Bitwise operators
To avoid surprises, use the bitwise operators with unsigned operands or std::bitset.
** Bit manipulation with bitwise operators and bit masks
*** useful bit flags
Save memory.
Pass multiple bool options.
*** how to set, clear, toggle, and query bit flags
To query bit states, we use bitwise AND:
#+begin_src cpp
if (flags & option4) ... // if option4 is set, do something
#+end_src
To set bits (turn on), we use bitwise OR:
#+begin_src cpp
flags |= option4; // turn option 4 on.
flags |= (option4 | option5); // turn options 4 and 5 on.
#+end_src
To clear bits (turn off), we use bitwise AND with bitwise NOT:
#+begin_src cpp
flags &= ~option4; // turn option 4 off
flags &= ~(option4 | option5); // turn options 4 and 5 off
#+end_src
To flip bit states, we use bitwise XOR:
#+begin_src cpp
flags ^= option4; // flip option4 from on to off, or vice versa
flags ^= (option4 | option5); // flip options 4 and 5
#+end_src
* Scope, Duration, and Linkage

** Compound statements
Keep the nesting level of your functions to 3 or less. If your function has a need for more nested levels, consider refactoring your function into sub-functions.

** Namespace
In general, you should avoid deeply nested namespaces (more than 3 levels).

alias: namespace Active = Foo::Goo;

** Local variable
Local variable have no linkage.

Define variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables.

** Global variable
Prefer defining global variables inside a namespace rather than in the global namespace.

Consider using a “g” or “g_” prefix when naming global variables (especially those defined in the global namespace), to help differentiate them from local variables and function parameters.

** variable shadow
Avoid variable shadowing.

** Internal Linkage
Give identifiers internal linkage when you have an explicit reason to disallow access from other files.

Consider giving all identifiers you don’t want accessible to other files internal linkage (use an unnamed namespace for this).

** External Linkage
If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you’re trying to make a forward declaration for the variable.

Although constexpr variables can be given external linkage via the extern keyword, they can not be forward declared as constexpr. This is because the compiler needs to know the value of the constexpr variable (at compile time). If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.

However, you can forward declare a constexpr variable as const, which the compiler will treat as a runtime const. This isn’t particularly useful.

** Non-const global variable are evil
Use local variables instead of global variables whenever possible.

Avoid initializing objects with static duration using other objects with static duration from a different translation unit.

Dynamic initialization of global variables is also susceptible to initialization order issues and should be avoided whenever possible.

** Protecting yourself from global destruction
First, prefix all non-namespaced global variables with “g” or “g_”, or better yet, put them in a namespace, to reduce the chance of naming collisions.

Second, instead of allowing direct access to the global variable, it’s a better practice to “encapsulate” the variable. Make sure the variable can only be accessed from within the file it’s declared in, e.g. by making the variable static or const, then provide external global “access functions” to work with the variable. These functions can ensure proper usage is maintained (e.g. do input validation, range checking, etc…). Also, if you ever decide to change the underlying implementation (e.g. move from one database to another), you only have to update the access functions instead of every piece of code that uses the global variable directly.

Third, when writing an otherwise standalone function that uses the global variable, don’t use the variable directly in your function body. Pass it in as an argument instead. That way, if your function ever needs to use a different value for some circumstance, you can simply vary the argument. This helps maintain modularity.

#+begin_src cpp :main no
#include <iostream>

namespace constants
{
    constexpr double gravity { 9.8 };
}

// This function can calculate the instant velocity for any gravity value (more useful)
double instantVelocity(int time, double gravity)
{
    return gravity * time;
}

int main()
{
    std::cout << instantVelocity(5, constants::gravity) << '\n'; // pass our constant to the function as a parameter

    return 0;
}
#+end_src

** Share global constant across multiple files
If you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file.

inline implicitly extern;

** Static local variables
Using the static keyword on a local variable changes its duration from automatic duration to static duration. This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). As a result, the static variable will retain its value even after it goes out of scope!

Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.

A static local variable has block scope like a local variable, but its lifetime is until the end of the program like a global variable.

Static local variables can be used when a function needs a persistent object that is not directly accessible outside of the function.

Const static local variables are generally okay to use.

Non-const static local variables should generally be avoided. If you do use them, ensure the variable never needs to be reset, and isn’t used to alter program flow.

** Scope, duration, linkage summary
| Type                                     | Example                         | Scope  | Duration  | Linkage  | Notes                        |
| Local variable                           | int x;                          | Block  | Automatic | None     |                              |
| Static local variable                    | static int s_x;                 | Block  | Static    | None     |                              |
| Dynamic local variable                   | int* x { new int{} };           | Block  | Dynamic   | None     |                              |
| Function parameter                       | void foo(int x)                 | Block  | Automatic | None     |                              |
| Internal non-const global variable       | static int g_x;                 | Global | Static    | Internal | Initialized or uninitialized |
| External non-const global variable       | int g_x;                        | Global | Static    | External | Initialized or uninitialized |
| Inline non-const global variable (C++17) | inline int g_x;                 | Global | Static    | External | Initialized or uninitialized |
| Internal constant global variable        | constexpr int g_x { 1 };        | Global | Static    | Internal | Must be initialized          |
| External constant global variable        | extern const int g_x { 1 };     | Global | Static    | External | Must be initialized          |
| Inline constant global variable (C++17)  | inline constexpr int g_x { 1 }; | Global | Static    | External | Must be initialized          |

*** Forward declaration summary
| Type                                      | Example                   | Notes                                             |
| Function forward declaration              | void foo(int x);          | Prototype only, no function body                  |
| Non-constant variable forward declaration | extern int g_x;           | Must be uninitialized                             |
| Const variable forward declaration        | extern const int g_x;     | Must be uninitialized                             |
| Constexpr variable forward declaration    | extern constexpr int g_x; | Not allowed, constexpr cannot be forward declared |

*** storage class specifier
| Specifier    | Meaning                                                                    | Note                |
| extern       | static (or thread_local) storage duration and external linkage             |                     |
| static       | static (or thread_local) storage duration and internal linkage             |                     |
| thread_local | thread storage duration                                                    |                     |
| mutable      | object allowed to be modified even if containing class is const            |                     |
| auto         | automatic storage duration                                                 | Deprecated in C++11 |
| register     | automatic storage duration and hint to the compiler to place in a register | Deprecated in C++17 |

** Using declarations and using directives
Avoid using-declarations in header files.

Prefer explicit namespace qualifiers over using-statements. Avoid using-directives altogether (except using namespace std::literals). Using-declarations are okay to use in .cpp files, after the #includes.

** Unnamed namespace and inline namespace
*** unname namespace
Prefer unnamed namespaces when you have content you want to keep local to a translation unit.

Avoid unnamed namespaces in header files.
*** Inline namespace
#+begin_src cpp
#include <iostream>

inline namespace V1 // declare an inline namespace named V1
{
    void doSomething()
    {
        std::cout << "V1\n";
    }
}

namespace V2 // declare a normal namespace named V2
{
    void doSomething()
    {
        std::cout << "V2\n";
    }
}

int main()
{
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()

    doSomething(); // calls the inline version of doSomething() (which is V1)

    return 0;
}
#+end_src
*** Mix unname and inline
#+begin_src cpp
#include <iostream>

namespace V1 // declare a normal namespace named V1
{
    void doSomething()
    {
        std::cout << "V1\n";
    }
}

inline namespace V2 // declare an inline namespace named V2
{
    namespace // unnamed namespace
    {
        void doSomething() // has internal linkage
        {
            std::cout << "V2\n";
        }

    }
}

int main()
{
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()

    doSomething(); // calls the inline version of doSomething() (which is V2)

    return 0;
}
#+end_src
* Control Flow
** Constexpr if statements
Favor constexpr if statements over non-constexpr if statements when the conditional is a constant expression.
** Switch statement basics
Switch type only allow for integral (or enumerated) types.

Place the default case last in the switch block.

Use the [​[fallthrough]] attribute (along with a null statement) to indicate intentional fallthrough.
*** Labels do not define a new scope
#+begin_src cpp
switch (1)
{
case 1: // does not create an implicit block
    foo(); // this is part of the switch scope, not an implicit block to case 1
    break; // this is part of the switch scope, not an implicit block to case 1
default:
    std::cout << "default case\n";
    break;
}
#+end_src
*** Variable declaration and initialization inside case statements
#+begin_src cpp
switch (1)
{
    int a; // okay: definition is allowed before the case labels
    int b{ 5 }; // illegal: initialization is not allowed before the case labels

case 1:
    int y; // okay but bad practice: definition is allowed within a case
    y = 4; // okay: assignment is allowed
    break;

case 2:
    int z{ 4 }; // illegal: initialization is not allowed if subsequent cases exist
    y = 5; // okay: y was declared above, so we can use it here too
    break;

case 3:
    break;
}
#+end_src

If defining variables used in a case statement, do so in a block inside the case.
#+begin_src cpp
switch (1)
{
case 1:
{ // note addition of explicit block here
    int x{ 4 }; // okay, variables can be initialized inside a block inside a case
    std::cout << x;
    break;
}

default:
    std::cout << "default case\n";
    break;
}
#+end_src
** Goto Statement
Statement labels must be associated with a statement.

Avoid goto statements (unless the alternatives are significantly worse for code readability).
** Introduction to loops and while statements
Favor while(true) for intentional infinite loops.

Integral loop variables should generally be a signed integral type.
** Do while
Favor while loops over do-while when given an equal choice.
** For loop
Avoid operator!= when doing numeric comparisons in the for-loop condition. Prefer operator< or operator<= where possible.

Defining multiple variables (in the init-statement) and using the comma operator (in the end-expression) is acceptable inside a for-statement.

Variables used only inside a loop should be defined inside the scope of the loop.

Prefer for-loops over while-loops when there is an obvious loop variable.
Prefer while-loops over for-loops when there is no obvious loop variable.

#+begin_src cpp
for (;;)
    statement;
// equivalent to, but prefer latter
while (true)
    statement;
#+end_src
** Break and continue
Use break and continue when they simplify your loop logic.
Use early returns when they simplify your function’s logic.
** Halt
std::exit is called implicitly when main() returns.
The std::exit() function does not clean up local variables in the current function or up the call stack.

std::atexit
#+begin_src cpp :main no
#include <cstdlib> // for std::exit()
#include <iostream>

void cleanup()
{
    // code here to do any kind of cleanup required
    std::cout << "cleanup!\n";
}

int main()
{
    // register cleanup() to be called automatically when std::exit() is called
    std::atexit(cleanup); // note: we use cleanup rather than cleanup() since we're not making a function call to cleanup() right now

    std::cout << 1 << '\n';

    std::exit(0); // terminate and return status code 0 to operating system

    // The following statements never execute
    std::cout << 2 << '\n';

    return 0;
}
#+end_src
In multi-threaded programs, calling std::exit() can cause your program to crash (because the thread calling std::exit() will cleanup static objects that may still be accessed by other threads). For this reason, C++ has introduced another pair of functions that work similarly to std::exit() and std::atexit() called std::quick_exit() and std::at_quick_exit(). std::quick_exit() terminates the program normally, but does not clean up static objects, and may or may not do other types of cleanup. std::at_quick_exit() performs the same role as std::atexit() for programs terminated with std::quick_exit().

Only use a halt if there is no safe or reasonable way to return normally from the main function. If you haven’t disabled exceptions, prefer using exceptions for handling errors safely.
** Generating random numbers using Mersenne Twister
*** Seeding with the system clock
#+begin_src cpp :main no
#include <iostream>
#include <random> // for std::mt19937
#include <chrono> // for std::chrono

int main()
{
	// Seed our Mersenne Twister using steady_clock
	std::mt19937 mt{ static_cast<std::mt19937::result_type>(
		std::chrono::steady_clock::now().time_since_epoch().count()
		) };

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
#+end_src
*** Seeding with the random device
std::random_device{} creates a value-initialized temporary object of type std::random_device. The () then calls operator() on that temporary object, which returns a randomized value (which we use as an initializer for our Mersenne Twister)

#+begin_src cpp
#include <iostream>
#include <random>

int main()
{
	std::random_device rd{};
	std::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; // get 8 integers of random numbers from std::random_device for our seed
	std::mt19937 mt{ ss }; // initialize our Mersenne Twister with the std::seed_seq

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
#+end_src

Only seed a given pseudo-random number generator once, and do not reseed it.
** Global random numbers (Random.h)
random.h
#+begin_src cpp :main no
#ifndef RANDOM_MT_H
#define RANDOM_MT_H

#include <chrono>
#include <random>

// This header-only Random namespace implements a self-seeding Mersenne Twister.
// Requires C++17 or newer.
// It can be #included into as many code files as needed (The inline keyword avoids ODR violations)
// Freely redistributable, courtesy of learncpp.com (https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/)
namespace Random
{
	// Returns a seeded Mersenne Twister
	// Note: we'd prefer to return a std::seed_seq (to initialize a std::mt19937), but std::seed can't be copied, so it can't be returned by value.
	// Instead, we'll create a std::mt19937, seed it, and then return the std::mt19937 (which can be copied).
	inline std::mt19937 generate()
	{
		std::random_device rd{};

		// Create seed_seq with clock and 7 random numbers from std::random_device
		std::seed_seq ss{
			static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),
				rd(), rd(), rd(), rd(), rd(), rd(), rd() };

		return std::mt19937{ ss };
	}

	// Here's our global std::mt19937 object.
	// The inline keyword means we only have one global instance for our whole program.
	inline std::mt19937 mt{ generate() }; // generates a seeded std::mt19937 and copies it into our global object

	// Generate a random int between [min, max] (inclusive)
	inline int get(int min, int max)
	{
		return std::uniform_int_distribution{min, max}(mt);
	}

	// The following function templates can be used to generate random numbers
	// when min and/or max are not type int
	// See https://www.learncpp.com/cpp-tutorial/function-template-instantiation/
	// You can ignore these if you don't understand them

	// Generate a random value between [min, max] (inclusive)
	// * min and max have same type
	// * Return value has same type as min and max
	// * Supported types:
	// *    short, int, long, long long
	// *    unsigned short, unsigned int, unsigned long, or unsigned long long
	// Sample call: Random::get(1L, 6L);             // returns long
	// Sample call: Random::get(1u, 6u);             // returns unsigned int
	template <typename T>
	T get(T min, T max)
	{
		return std::uniform_int_distribution<T>{min, max}(mt);
	}

	// Generate a random value between [min, max] (inclusive)
	// * min and max can have different types
	// * Must explicitly specify return type as template type argument
	// * min and max will be converted to the return type
	// Sample call: Random::get<std::size_t>(0, 6);  // returns std::size_t
	// Sample call: Random::get<std::size_t>(0, 6u); // returns std::size_t
	// Sample call: Random::get<std::int>(0, 6u);    // returns int
	template <typename R, typename S, typename T>
	R get(S min, T max)
	{
		return get<R>(static_cast<R>(min), static_cast<R>(max));
	}
}

#endif
#+end_src

main.cpp
#+begin_src cpp :main no
#include "Random.h" // defines Random::mt, Random::get(), and Random::generate()
#include <cstddef> // for std::size_t
#include <iostream>

int main()
{
	// We can use Random::get() to generate random numbers

	std::cout << Random::get(1, 6) << '\n';   // returns int between 1 and 6
	std::cout << Random::get(1u, 6u) << '\n'; // returns unsigned int between 1 and 6

	// The following uses a template type argument
	// See https://www.learncpp.com/cpp-tutorial/function-template-instantiation/
	std::cout << Random::get<std::size_t>(1, 6u) << '\n'; // returns std::size_t between 1 and 6

	// We can access Random::mt directly if we have our own distribution

	// Let's create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };
	for (int count{ 1 }; count <= 10; ++count)
	{
		std::cout << die6(Random::mt) << '\t'; // generate a roll of the die here
	}

	std::cout << '\n';

	return 0;
}
#+end_src
* Error Detection and Handling
** Code Coverage
Aim for 100% branch coverage of your code.

Loop coverage (informally called the 0, 1, 2 test) says that if you have a loop in your code, you should ensure it works properly when it iterates 0 times, 1 time, and 2 times.

*** Testing different categories of input
For integers, make sure you’ve considered how your function handles negative values, zero, and positive values. You should also check for overflow if that’s relevant.

For floating point numbers, make sure you’ve considered how your function handles values that have precision issues (values that are slightly larger or smaller than expected). Good double type values to test with are 0.1 and -0.1 (to test numbers that are slightly larger than expected) and 0.6 and -0.6 (to test numbers that are slightly smaller than expected).

For strings, make sure you’ve considered how your function handles an empty string, an alphanumeric string, strings that have whitespace (leading, trailing, and inner), and strings that are all whitespace.

If your function takes a pointer, don’t forget to test nullptr as well (don’t worry if this doesn’t make sense, we haven’t covered it yet).

*** std::cout vs std::cerr vs logging
Use std::cout for all conventional, user-facing text.

For an interactive program, use std::cout for normal user-facing error messages (e.g. “Your input was invalid”). Use std::cerr or a logfile for status and diagnostic information that may be helpful for diagnosing issues but probably isn’t interesting for normal users. This can include technical warnings and errors (e.g. bad input to function x), status updates (e.g. successfully opened file x, failed to connect to internet service x), percentage completion of long tasks (e.g. encoding 50% complete), etc…

For a non-interactive program (tool or service), use std::cerr for error output only (e.g. could not open file x). This allows errors to be displayed or parsed separately from normal output.

For any application type that is transactional in nature (e.g. one that processes specific events, such as an interactive web browser or non-interactive web server), use a logfile to produce a transactional log of events that can be reviewed later. This can include outputting to the logfile which file is being processed, updates on the percentage complete, timestamps of when it started certain stages of computing, warning and error messages, etc…

*** std::cin handling invalid input
#+begin_src cpp
#include <cstdlib> // for std::exit
#include <iostream>
#include <limits> // for std::numeric_limits

void ignoreLine()
{
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

// returns true if extraction failed, false otherwise
bool clearFailedExtraction()
{
    // Check for failed extraction
    if (!std::cin) // If the previous extraction failed
    {
        if (std::cin.eof()) // If the stream was closed
        {
            exit(0); // Shut down the program now
        }

        // Let's handle the failure
        std::cin.clear(); // Put us back in 'normal' operation mode
        ignoreLine();     // And remove the bad input

        return true;
    }

    return false;
}

double getDouble()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter a decimal number: ";
        double x{};
        std::cin >> x;

        if (clearFailedExtraction())
        {
            std::cout << "Oops, that input is invalid.  Please try again.\n";
            continue;
        }

        ignoreLine(); // Remove any extraneous input
        return x;     // Return the value we extracted
    }
}

char getOperator()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter one of the following: +, -, *, or /: ";
        char operation{};
        std::cin >> operation;

        if (!clearFailedExtraction()) // we'll handle error messaging if extraction failed below
             ignoreLine(); // remove any extraneous input (only if extraction succeded)

        // Check whether the user entered meaningful input
        switch (operation)
        {
        case '+':
        case '-':
        case '*':
        case '/':
            return operation; // Return the entered char to the caller
        default: // Otherwise tell the user what went wrong
            std::cout << "Oops, that input is invalid.  Please try again.\n";
        }
    }
}

void printResult(double x, char operation, double y)
{
    std::cout << x << ' ' << operation << ' ' << y << " is ";

    switch (operation)
    {
    case '+':
        std::cout << x + y << '\n';
        return;
    case '-':
        std::cout << x - y << '\n';
        return;
    case '*':
        std::cout << x * y << '\n';
        return;
    case '/':
        if (y == 0.0)
            break;

        std::cout << x / y << '\n';
        return;
    }

    std::cout << "???";  // Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program
}

int main()
{
    double x{ getDouble() };
    char operation{ getOperator() };
    double y{ getDouble() };

    // Handle division by 0
    while (operation == '/' && y == 0.0)
    {
        std::cout << "The denominator cannot be zero.  Try again.\n";
        y = getDouble();
    }

    printResult(x, operation, y);

    return 0;
}
#+end_src

*** Assert and static_assert
Use assertions to document cases that should be logically impossible.

If the macro NDEBUG is defined, the assert macro gets disabled.

#+begin_src cpp
assert(moved && "Need to handle case where student was just moved to another classroom");
#+end_src

A static_assert is an assertion that is checked at compile-time rather than at runtime, with a failing static_assert causing a compile error. Unlike assert, which is declared in the <cassert> header, static_assert is a keyword, so no header needs to be included to use it.
* Type Conversion, Type Aliases, and Type Deduction
** Narrowing conversions
From a floating point type to an integral type.
From a floating point type to a narrower or lesser ranked floating point type, unless the value being converted is constexpr and is in range of the destination type (even if the destination type doesn’t have the precision to store all the significant digits of the number).
From an integral to a floating point type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.
From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type. This covers both wider to narrower integral conversions, as well as integral sign conversions (signed to unsigned, or vice-versa).

If you need to perform a narrowing conversion, use static_cast to convert it into an explicit conversion.
Some constexpr conversions aren’t considered narrowing.

** Arithmetic conversions
The usual arithmetic conversion rules are somewhat complex, so we’ll simplify a bit. The compiler has a ranked list of types that looks something like this:
*** The usual arithmetic conversion rules
1. long double (highest rank)
2. double
3. float
4. long long
5. long
6. int (lowest rank)

**** sign and unsigned
If the rank of the unsigned operand is greater than the rank of the signed operand, the signed operand is converted to the type of the unsigned operand.
If the type of the signed operand can represent all the values of the type of the unsigned operand, the type of the unsigned operand is converted to the type of the signed operand.
Otherwise both operands are converted to the corresponding unsigned type of the signed operand.
** Explicit type conversion (casting) and static_cast
Avoid using C-style casts.
Avoid const casts and reinterpret casts unless you have a very good reason to use them.
** Typedefs and type aliases
#+begin_src cpp
using Distance = double; // define Distance as an alias for type double
#+end_src
Name your type aliases starting with a capital letter and do not use a suffix (unless you have a specific reason to do otherwise).

Prefer type aliases over typedefs.

Use type aliases judiciously, when they provide a clear benefit to code readability or code maintenance.
** Type deduction for objects using the auto keyword
Use type deduction for your variables when the type of the object doesn’t matter.

Favor an explicit type when you require a specific type that differs from the type of the initializer, or when your object is used in a context where making the type obvious is useful.
*** Type deduction drops const / constexpr qualifiers
#+begin_src cpp
int main()
{
    const int x { 5 };  // x has type const int (compile-time const)
    auto y { x };       // y will be type int (const is dropped)

    constexpr auto z { x }; // z will be type constexpr int (constexpr is reapplied)

    return 0;
}
#+end_src
*** Type deduction for string literals
#+begin_src cpp
#include <string>
#include <string_view>

int main()
{
    using namespace std::literals; // easiest way to access the s and sv suffixes

    auto s { "Hello, world" }; // s will be type const char*, not std::string
    auto s1 { "goo"s };  // "goo"s is a std::string literal, so s1 will be deduced as a std::string
    auto s2 { "moo"sv }; // "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view

    return 0;
}
#+end_src
** Type deduction for functions
Favor explicit return types over function return type deduction for normal functions.

Auto can also be used as a function return type to have the compiler infer the function’s return type from the function’s return statements, though this should be avoided for normal functions. Auto is used as part of the trailing return syntax.
* Function Overloading and Function Templates
** Function overload differentiation
| Function property    | Used for differentiation | Notes                                                                                        |
|----------------------+--------------------------+----------------------------------------------------------------------------------------------|
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |
** Deleting all non-matching overloads
= delete means “I forbid this”, not “this doesn’t exist”.
#+begin_src cpp
#include <iostream>

// This function will take precedence for arguments of type int
void printInt(int x)
{
    std::cout << x << '\n';
}

// This function template will take precedence for arguments of other types
// Since this function template is deleted, calls to it will halt compilation
template <typename T>
void printInt(T x) = delete;

int main()
{
    printInt(97);   // okay
    printInt('a');  // compile error
    printInt(true); // compile error

    return 0;
}
#+end_src
** Default arguments
If a parameter is given a default argument, all subsequent parameters (to the right) must also be given default arguments.
If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.
** Function templates
Templates can work with types that didn’t even exist when the template was written. This helps make template code both flexible and future proof!

Use a single capital letter starting with T (e.g. T, U, V, etc…) to name type template parameters that are used in trivial or obvious ways and represent “any reasonable type”.

If the type template parameter has a non-obvious usage or specific requirements that must be met, then a more descriptive name is warranted. (e.g. Allocator or TAllocator).
** function template instantiation
Favor the normal function call syntax when making calls to a function instantiated from a function template (unless you need the function template version to be preferred over a matching non-template function).

The compiler will instantiate and compile function templates that do not make sense semantically as long as they are syntactically valid. It is your responsibility to make sure you are calling such function templates with arguments that make sense.

Use function templates to write generic code that can work with a wide variety of types whenever you have the need.

Templates that are needed in multiple files should be defined in a header file, and then #included wherever needed. This allows the compiler to see the full template definition and instantiate the template when needed.
** Function templates with multiple template types
#+begin_src cpp :main no
#include <iostream>

template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max(2, 3.5) << '\n';

    return 0;
}
#+end_src
*** Abbreviated function templates 
#+begin_src cpp
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
#+end_src
is shorthand in C++20 for the following:
#+begin_src cpp
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
#+end_src
Feel free to use abbreviated function templates with a single auto parameter, or where each auto parameter should be an independent type (and your language standard is set to C++20 or newer).
** Non-type template parameters
A non-type template parameter can be any of the following types:

- An integral type
- An enumeration type
- std::nullptr_t
- A floating point type (since C++20)
- A pointer or reference to an object
- A pointer or reference to a function
- A pointer or reference to a member function
- A literal class type (since C++20)
*** example
#+begin_src cpp :main no
#include <iostream>

template <int N> // declare a non-type template parameter of type int named N
void print()
{
    std::cout << N << '\n'; // use value of N here
}

int main()
{
    print<5>(); // 5 is our non-type template argument

    return 0;
}
#+end_src
Use N as the name of an int non-type template parameter.

Non-type template parameters are used primarily when we need to pass constexpr values to functions (or class types) so they can be used in contexts that require a constant expression.
* Compound Types: References and Pointers
** Lvalue and Rvalue
Lvalue expressions evaluate to an identifiable object.
Rvalue expressions evaluate to a value.
** lvalue reference
When defining a reference, place the ampersand next to the type (not the reference variable’s name).
References can’t be reseated (changed to refer to another object)


** lvalue reference to const
Favor lvalue references to const over lvalue references to non-const unless you need to modify the object being referenced.

Lvalue references can only bind to modifiable lvalues.

Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.
*** Initializing an lvalue reference to const with a value of a different type
If you try to bind a const lvalue reference to a value of a different type, the compiler will create a temporary object of the same type as the reference, initialize it using the value, and then bind the reference to the temporary.

Lifetime extension only works when a const reference is directly bound to a temporary. Temporaries returned from a function (even ones returned by const reference) are not eligible for lifetime extension.
*** constexpr lvalue reference
When applied to a reference, constexpr allows the reference to be used in a constant expression. Constexpr references have a particular limitation: they can only be bound to objects with static duration (either globals or static locals). This is because the compiler knows where static objects will be instantiated in memory, so it can treat that address as a compile-time constant.

#+begin_src cpp :main no
int g_x { 5 };

int main()
{
    [[maybe_unused]] constexpr int& ref1 { g_x }; // ok, can bind to global

    static int s_x { 6 };
    [[maybe_unused]] constexpr int& ref2 { s_x }; // ok, can bind to static local

    int x { 6 };
    [[maybe_unused]] constexpr int& ref3 { x }; // compile error: can't bind to non-static object

    return 0;
}
#+end_src
** pass by const lvalue reference
Favor passing by const reference over passing by non-const reference unless you have a specific reason to do otherwise (e.g. the function needs to change the value of an argument).
*** When to pass by (const) reference
Prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy. If you’re not sure whether an object is cheap or expensive to copy, favor pass by const reference.

As a rule of thumb, pass fundamental types by value, and class (or struct) types by const reference.

Other common types to pass by value: enumerated types and std::string_view.
Other common types to pass by (const) reference: std::string, std::array, and std::vector.
** Pointer
When declaring a pointer type, place the asterisk next to the type name.
Always initialize your pointers.

#+begin_src cpp
int* ptr1, ptr2;   // incorrect: ptr1 is a pointer to an int, but ptr2 is just a plain int!
int* ptr3, * ptr4; // correct: ptr3 and ptr4 are both pointers to an int
#+end_src
*** Pointer vs Reference
- References must be initialized, pointers are not required to be initialized (but should be).
- References are not objects, pointers are.
- References can not be reseated (changed to reference something else), pointers can change what they are pointing at.
- References must always be bound to an object, pointers can point to nothing (we’ll see an example of this in the next lesson).
- References are “safe” (outside of dangling references), pointers are inherently dangerous (we’ll also discuss this in the next lesson).
** Null pointer
Value initialize your pointers (to be null pointers) if you are not initializing them with the address of a valid object.
Use nullptr when you need a null pointer literal for initialization, assignment, or passing a null pointer to a function.

#+begin_src cpp :main no
#include <iostream>

int main()
{
    int x { 5 };
    int* ptr { &x };

    // pointers convert to Boolean false if they are null, and Boolean true if they are non-null
    if (ptr) // implicit conversion to Boolean
        std::cout << "ptr is non-null\n";
    else
        std::cout << "ptr is null\n";

    int* nullPtr {};
    std::cout << "nullPtr is " << (nullPtr ? "non-null\n" : "null\n"); // implicit conversion to Boolean

    return 0;
}
#+end_src

Conditionals can only be used to differentiate null pointers from non-null pointers. There is no convenient way to determine whether a non-null pointer is pointing to a valid object or dangling (pointing to an invalid object).

A pointer should either hold the address of a valid object, or be set to nullptr. That way we only need to test pointers for null, and can assume any non-null pointer is valid.

When an object is destroyed, any pointers to the destroyed object will be left dangling (they will not be automatically set to nullptr). It is your responsibility to detect these cases and ensure those pointers are subsequently set to nullptr.

Favor references over pointers unless the additional capabilities provided by pointers are needed.
** Pointer and const
#+begin_src cpp :main no
int main()
{
    int v{ 5 };

    int* ptr0 { &v };             // points to an "int" but is not const itself, so this is a normal pointer.
    const int* ptr1 { &v };       // points to a "const int" but is not const itself, so this is a pointer to a const value.
    int* const ptr2 { &v };       // points to an "int" and is const itself, so this is a const pointer (to a non-const value).
    const int* const ptr3 { &v }; // points to a "const int" and is const itself, so this is a const pointer to a const value.

    // if the const is on the left side of the *, the const belongs to the value
    // if the const is on the right side of the *, the const belongs to the pointer

    return 0;
}
#+end_src
** pass by address
Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.

nullptr has type std::nullptr_t (defined in header <cstddef>).
*** Pass by address… by reference
A function to change what a pointer argument points to.
#+begin_src cpp :main no
#include <iostream>

void nullify(int*& refptr) // refptr is now a reference to a pointer
{
    refptr = nullptr; // Make the function parameter a null pointer
}

int main()
{
    int x{ 5 };
    int* ptr{ &x }; // ptr points to x

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");

    nullify(ptr);

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
    return 0;
}
#+end_src
** return by ref or address
Avoid returning references to non-const local static variables.
Prefer return by reference over return by address unless the ability to return “no object” (using nullptr) is important.
** in and out parameters
Avoid out-parameters (except in the rare case where no better options exist).

Prefer pass by reference for non-optional out-parameters.
** type dedution with pointers references and const
If you want a const pointer, pointer to const, or const pointer to const, reapply the const qualifier(s) even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.
If you want a const reference, reapply the const qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.
*** Top-level const and low-level const
A top-level const is a const qualifier that applies to an object itself. For example:
#+begin_src cpp
const int x;    // this const applies to x, so it is top-level
int* const ptr; // this const applies to ptr, so it is top-level
#+end_src

In contrast, a low-level const is a const qualifier that applies to the object being referenced or pointed to:
#+begin_src cpp
const int& ref; // this const applies to the object being referenced, so it is low-level
const int* ptr; // this const applies to the object being pointed to, so it is low-level
#+end_src

A reference to a const value is always a low-level const. A pointer can have a top-level, low-level, or both kinds of const:
#+begin_src cpp
const int* const ptr; // the left const is low-level, the right const is top-level
#+end_src

When we say that type deduction drops const qualifiers, it only drops top-level consts. Low-level consts are not dropped.
** std::optional
| Behavior           | Pointer                              | std::optional                              |
|--------------------+--------------------------------------+--------------------------------------------|
| Hold no value      | initialize/assign {} or std::nullptr | initialize/assign {} or std::nullopt       |
| Hold a value       | initialize/assign an address         | initialize/assign a value                  |
| Check if has value | implicit conversion to bool          | implicit conversion to bool or has_value() |
| Get value          | dereference                          | dereference or value()                     |
Return a std::optional (instead of a sentinel value) for functions that may fail, unless your function needs to return additional information about why it failed.
std::expected (introduced in C++23) is designed to handle the case where a function can return either an expected value or an unexpected error code.

Prefer std::optional for optional return types.

Prefer function overloading for optional function parameters (when possible). Otherwise, use std::optional<T> for optional arguments when T would normally be passed by value. Favor const T* when T is expensive to copy.
* Compound Types: Enums and Structs
** Unscoped enumerations
Name your enumerated types starting with a capital letter. Name your enumerators starting with a lower case letter.

Prefer putting your enumerations inside a named scope region (such as a namespace or class) so the enumerators don’t pollute the global namespace.
** Unscoped enumerator integral conversions
Avoid assigning explicit values to your enumerators unless you have a compelling reason to do so.

Make the enumerator representing 0 the one that is the best default meaning for your enumeration. If no good default meaning exists, consider adding an “invalid” or “unknown” enumerator that has value 0, so that state is explicitly documented and can be explicitly handled where appropriate.

Specify the base type of an enumeration only when necessary.
Because std::int8_t and std::uint8_t are usually type aliases for char types, using either of these types as the enum base will most likely cause the enumerators to print as char values rather than int values.

As of C++17, if an unscoped enumeration has an explicitly specified base, then the compiler will allow you to list initialize an unscoped enumeration using an integral value:(Or static_cast)
#+begin_src cpp :main no
enum Pet: int // we've specified a base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet1 { 2 }; // ok: can brace initialize unscoped enumeration with specified base with integer (C++17)
    Pet pet2 (2);   // compile error: cannot direct initialize with integer
    Pet pet3 = 2;   // compile error: cannot copy initialize with integer

    pet1 = 3;       // compile error: cannot assign with integer

    return 0;
}
#+end_src
** Scoped enumerations (enum classes)
Favor scoped enumerations over unscoped enumerations unless there’s a compelling reason to do otherwise.
*** convert a scoped enumerator to an integer
#+begin_src cpp :main no
#include <iostream>
#include <utility> // for std::to_underlying() (C++23)

int main()
{
    enum class Color
    {
        red,
        blue,
    };

    Color color { Color::blue };

    std::cout << color << '\n'; // won't work, because there's no implicit conversion to int
    std::cout << static_cast<int>(color) << '\n';   // explicit conversion to int, will print 1
    std::cout << std::to_underlying(color) << '\n'; // convert to underlying type, will print 1 (C++23)

    return 0;
}
#+end_src
** Struct aggregate initialization
*** Overloading operator<< to print a struct && Designated initializers
When adding a new member to an aggregate, it’s safest to add it to the bottom of the definition list so the initializers for other members don’t shift.
#+begin_src cpp
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

std::ostream& operator<<(std::ostream& out, const Employee& e)
{
    out << "id: " << e.id << " age: " << e.age << " wage: " << e.wage;
    return out;
}

int main()
{
    Employee joe { .id{2}, .age{28} }; // joe.wage will be value-initialized to 0.0
    std::cout << joe << '\n';

    return 0;
}
#+end_src
*** default member initialization
Provide a default value for all members. This ensures that your members will be initialized even if the variable definition doesn’t include an initializer list.

For aggregates, prefer value initialization (with an empty braces initializer) to default initialization (with no braces).
** struct miscellany
In most cases, we want our structs (and classes) to be owners. The easiest way to enable this is to ensure each data member has an owning type (e.g. not a viewer, pointer, or reference).

You can minimize padding by defining your members in decreasing order of size.
** member selection with pointer and reference
When using a pointer to access a member, use the member selection from pointer operator (->) instead of the member selection operator (.).
** Class template argument deduction (CTAD) and deduction guides
*** Type template parameters with default values
#+begin_src cpp
template <typename T=int, typename U=int> // default T and U to type int
struct Pair
{
    T first{};
    U second{};
};

template <typename T, typename U>
Pair(T, U) -> Pair<T, U>;

int main()
{
    Pair<int, int> p1{ 1, 2 }; // explicitly specify class template Pair<int, int> (C++11 onward)
    Pair p2{ 1, 2 };           // CTAD used to deduce Pair<int, int> from the initializers (C++17)

    Pair p3;                   // uses default Pair<int, int>

    return 0;
}
#+end_src
*** CTAD doesn’t work with non-static member initialization
#+begin_src cpp
#include <utility> // for std::pair

struct Foo
{
    std::pair<int, int> p1{ 1, 2 }; // ok, template arguments explicitly specified
    std::pair p2{ 1, 2 };           // compile error, CTAD can't be used in this context
};

int main()
{
    std::pair p3{ 1, 2 };           // ok, CTAD can be used here
    return 0;
}
*** CTAD doesn’t work with function parameters
In such cases, you should use a template instead
#+begin_src cpp
#include <iostream>
#include <utility>

void print(std::pair p) // compile error, CTAD can't be used here
{
    std::cout << p.first << ' ' << p.second << '\n';
}

int main()
{
    std::pair p { 1, 2 }; // p deduced to std::pair<int, int>
    print(p);

    return 0;
}
#+end_src
#+end_src
** Alias templates
#+begin_src cpp
#include <iostream>

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

// Here's our alias template
// Alias templates must be defined in global scope
template <typename T>
using Coord = Pair<T>; // Coord is an alias for Pair<T>

// Our print function template needs to know that Coord's template parameter T is a type template parameter
template <typename T>
void print(const Coord<T>& c)
{
    std::cout << c.first << ' ' << c.second << '\n';
}

int main()
{
    Coord<int> p1 { 1, 2 }; // Pre C++-20: We must explicitly specify all type template argument
    Coord p2 { 1, 2 };      // In C++20, we can use alias template deduction to deduce the template arguments in cases where CTAD works

    std::cout << p1.first << ' ' << p1.second << '\n';
    print(p2);

    return 0;
}
#+end_src
* Introduction to Classes
** Member functions
With non-member functions, we have to explicitly pass an object to the function to work with, and members are explicitly accessed through that object.

With member functions, we implicitly pass an object to the function to work with, and members are implicitly accessed through that object.

Avoid using other members inside default member initializers.
** Structs and member functions
Member functions can be used with both structs and classes.

However, structs should avoid defining constructor member functions, as doing so makes them a non-aggregate.

If your class type has no data members, prefer using a namespace.
** Const class objects and const member functions
Const objects may not call non-const member functions

A member function that does not (and will not ever) modify the state of the object should be made const, so that it can be called on both const and non-const objects.

Be careful about what member functions you apply const to. Once a member function is made const, that function can be called on const objects. Later removal of const on a member function will break any code that calls that member function on a const object.

Member function const and non-const overloading
** Public and private members and access specifiers
Consider naming your private data members starting with an “m_” prefix to help distinguish them from the names of local variables, function parameters, and member functions.

Public members of classes may also follow this convention if desired. However, the public members of structs typically do not use this prefix since structs generally do not have many member functions (if any).

*** access level summary
| Access level | Access specifier | Member access | Derived class access | Public access |
|--------------+------------------+---------------+----------------------+---------------|
| Public       | public:          | yes           | yes                  | yes           |
| Protected    | protected:       | yes           | yes                  | no            |
| Private      | private:         | yes           | no                   | no            |

Classes should generally make member variables private (or protected), and member functions public.

Structs should generally avoid using access specifiers (all members will default to public).

** Access functions
- If your class has no invariants and requires a lot of access functions, consider using a struct (whose data members are public) and providing direct access to members instead.
- Prefer implementing behaviors or actions instead of access functions. For example, instead of a setAlive(bool) setter, implement a kill() and a revive() function.
- Only provide access functions in cases where the public would reasonably need to get or set the value of an individual member.

** Member function return by ref
A member function returning a reference should return a reference of the same type as the data member being returned, to avoid unnecessary conversions.

An rvalue object is destroyed at the end of the full expression in which it is created. Any references to members of the rvalue object are left dangling at that point.

A reference to a member of an rvalue object can only be safely used within the full expression where the rvalue object is created.

Prefer to use the return value of a member function that returns by reference immediately, to avoid issues with dangling references when the implicit object is an rvalue.

** encapsulation
Prefer implementing functions as non-members when possible (especially functions that contain application specific data or logic).

Declare public members first, protected members next, and private members last. This spotlights the public interface and de-emphasizes implementation details.

** constructor member initializer lists
Member variables in a member initializer list should be listed in order that they are defined in the class.

Prefer using the member initializer list to initialize your members over assigning values in the body of the constructor.

** default constructor and default arguments
Prefer an explicitly defaulted default constructor (= default) over a default constructor with an empty body.

** delegating constructors
Constructors should not be called directly from the body of another function. Doing so will either result in a compilation error, or will value initialize a temporary object and then discard it (which likely isn’t what you want).

If you have multiple constructors, consider whether you can use delegating constructors to reduce duplicate code.

Members for which the user must provide initialization values should be defined first (and as the leftmost parameters of the constructor). Members for which the user can optionally provide initialization values (because the default values are acceptable) should be defined second (and as the rightmost parameters of the constructor).

The best way to do this is to use a static constexpr member inside the class:
#+begin_src cpp :main no
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
    static constexpr int default_id { 0 }; // define a named constant with our desired initialization value

    std::string m_name{};
    int m_id{ default_id }; // we can use it here

public:

    Employee(std::string_view name, int id = default_id) // and we can use it here
        : m_name{ name }, m_id{ id }
    {
        std::cout << "Employee " << m_name << " created\n";
    }
};

int main()
{
    Employee e1{ "James" };
    Employee e2{ "Dave", 42 };
}
#+end_src

** Introduction to the copy constructor
Copy constructors should have no side effects beyond copying.
Prefer the implicit copy constructor, unless you have a specific reason to create your own.
If you write your own copy constructor, the parameter should be a const lvalue reference.

Using = default to generate a default copy constructor.
Using = delete to prevent copies.

** Class initialization and copy elision
Copy elision is a compiler optimization technique that allows the compiler to remove unnecessary copying of objects.

** Converting constructors and the explicit keyword
Make any constructor that accepts a single argument explicit by default. If an implicit conversion between types is both semantically equivalent and performant, you can consider making the constructor non-explicit.

Do not make copy or move constructors explicit, as these do not perform conversions.

** constexpre aggregates and classes
If you want your class to be able to be evaluated at compile-time, make your member functions and constructor constexpr.
Constexpr is part of the interface of the class, and removing it later will break callers who are calling the function in a constant context.
* More on Classes
** Classes and header files
Prefer to put your class definitions in a header file with the same name as the class. Trivial member functions (such as access functions, constructors with empty bodies, etc…) can be defined inside the class definition.

Prefer to define non-trivial member functions in a source file with the same name as the class.

Functions defined inside the class definition are implicitly inline, which allows them to be #included into multiple code files without violating the ODR.

Functions defined outside the class definition are not implicitly inline. They can be made inline by using the inline keyword.

Put any default arguments for member functions inside the class definition.
** nested types member types
Define any nested types at the top of your class type.
** class templates with member functions
Any member function templates defined outside the class definition should be defined just below the class definition (in the same file).
*** Injected class names
Pair is the injected class name of Pair<T>, within the scope of our Pair<T> class template, any use of Pair will be treated as if we had written Pair<T> instead.
** static member variables
Static member variables are member variables that belong to the class rather than objects of the class.

Access static members using the class name and the scope resolution operator (::).

Make your static members inline or constexpr so they can be initialized inside the class definition.

Non-static members may not use auto or CTAD.
** Static member functions
Static member functions have no *this pointer.
C++ does not support static constructors

*** Pure static classes vs namespaces
In general, a static class is preferable when you have static data members and/or need access controls. Otherwise, prefer a namespace.
** friend non member functions
Friendship is always granted by the class whose members will be accessed (not by the class or function desiring access). Between access controls and granting friendship, a class always retains the ability to control who can access its members.

A friend function should prefer to use the class interface over direct access whenever possible.

Prefer to implement a function as a non-friend when possible and reasonable.
** Friend classes and friend member function
Nor is friendship inherited. If class A makes B a friend, classes derived from B are not friends of A.

Friend member function need notice declaration order if define in single file.
* Dynamic arrays: std::vector
** Introduction to std::vector and list constructors
When constructing a container (or any type that has a list constructor) with initializers that are not element values, use direct initialization.
*** When a std::vector is a member of a class type

We must use either copy initialization or list initialization (direct or copy).
CTAD is not allowed (so we must explicitly specify the element type).

#+begin_src cpp
struct Foo
{
    std::vector<int> v{ std::vector<int>(8) }; // ok
};
#+end_src
*** cosnt and constexpr std::vector
A const std::vector must be initialized, and then cannot be modified. The elements of such a vector are treated as if they were const.

The element type of a std::vector must not be defined as const (e.g. std::vector<const int> is disallowed).

One of the biggest downsides of std::vector is that it cannot be made constexpr. If you need a constexpr array, use std::array.
** std::vector and the unsigned length and subscript problem
use std::ssize() or std::size() instead of size();

** Returning std::vector, and an introduction to move semantics
std::vector and std::string both support move semantics.

To summarize, for move-capable types, we prefer to pass by const reference, and return by value.

** Arrays, loops, and sign challenge solutions
Because size_type is almost always a typedef for size_t, many programmers just skip using size_type altogether and use the easier to remember and type std::size_t directly.

Or std::vector<int>::size_type;

*** What signed type should we use?
If you are dealing with very large arrays, or if you want to be a bit more defensive, you can use the strangely named std::ptrdiff_t. This typedef is often used as the signed counterpart to std::size_t.

In C++23, the Z suffix can be used to define a literal of the type that is the signed counterpart to std::size_t (probably std::ptrdiff_t):
#+begin_src cpp
for (auto index{ 0Z }; index < static_cast<std::ptrdiff_t>(arr.size()); ++index)
#+end_src

If you want more evidence that the designers of C++ now believe that signed indices are the way to go, consider the introduction of std::ssize() in C++20. This function returns the size of an array type as a signed type (likely ptrdiff_t).

Avoid array indexing with integral values whenever possible.

** Range-based for loops (for-each)
Favor range-based for loops over regular for-loops when traversing containers.

Use type deduction (auto) with range-based for loops to have the compiler deduce the type of the array element.

Avoid element copies using references.

*** For range-based for loops, prefer to define the element type as:
- auto when you want to modify copies of the elements.
- auto& when you want to modify the original elements.
- const auto& otherwise (when you just need to view the original elements).

*** Range-based for loops in reverse
As of C++20, you can use the std::views::reverse capability of the Ranges library to create a reverse view of the elements that can be traversed:  
#+begin_src cpp :main no
#include <iostream>
#include <ranges> // C++20
#include <string_view>
#include <vector>

int main()
{
    std::vector<std::string_view> words{ "Alex", "Bobby", "Chad", "Dave" }; // sorted in alphabetical order

    for (const auto& word : std::views::reverse(words)) // create a reverse view
        std::cout << word << ' ';

    std::cout << '\n';

    return 0;
}
#+end_src

** Array indexing and length using enumerators
Use a static_assert to ensure the length of your constexpr array matches your count enumerator.
Use an assert to ensure the length of your non-constexpr array matches your count enumerator.

If you’re going to be doing a lot of enumerator to integral conversions, it’s probably better to just use a standard enum inside a namespace (or class).

** std::vector resizing and capacity
The length of a vector is how many elements are “in use”.
The capacity of a vector is how many elements have been allocated in memory.

Reallocation is typically expensive. Avoid unnecessary reallocations.

A subscript is only valid if it is between 0 and the vector’s length (not its capacity)!

** std::vector and stack behavior
| Function Name  | Stack Operation | Behavior                                                             | Notes                                          |
|----------------+-----------------+----------------------------------------------------------------------+------------------------------------------------|
| push_back()    | Push            | Put new element on top of stack                                      | Adds the element to end of vector              |
| pop_back()     | Pop             | Remove the top element from the stack                                | Returns void, removes element at end of vector |
| back()         | Top or Peek     | Get the top element on the stack                                     | Does not remove item                           |
| emplace_back() | Push            | Alternate form of push_back() that can be more efficient (see below) | Adds element to end of vector                  |

push_back() and emplace_back() will increment the length of a std::vector, and will cause a reallocation to occur if the capacity is not sufficient to insert the value.

The resize() member function changes the length of the vector, and the capacity (if necessary).
The reserve() member function changes just the capacity (if necessary)

Use resize() when accessing a vector via indexing. This changes the length of the vector so your indices will be valid.
Use reserve() when accessing a vector using stack operations. This adds capacity without changing the length of the vector.

*** push_back() vs emplace_back()
Both push_back() and emplace_back() push an element onto the stack. If the object to be pushed already exists, push_back() and emplace_back() are equivalent, and push_back() should be preferred.

However, in cases where we are creating a temporary object (of the same type as the vector’s element) for the purpose of pushing it onto the vector, emplace_back() can be more efficient:

#+begin_src cpp :main no
#include <iostream>
#include <string>
#include <string_view>
#include <vector>

class Foo
{
private:
    std::string m_a{};
    int m_b{};

public:
    Foo(std::string_view a, int b)
        : m_a { a }, m_b { b }
        {}

    explicit Foo(int b)
        : m_a {}, m_b { b }
        {};
};

int main()
{
	std::vector<Foo> stack{};

	// When we already have an object, push_back and emplace_back are similar in efficiency
	Foo f{ "a", 2 };
	stack.push_back(f);    // prefer this one
	stack.emplace_back(f);

	// When we need to create a temporary object to push, emplace_back is more efficient
	stack.push_back({ "a", 2 }); // creates a temporary object, and then copies it into the vector
	stack.emplace_back("a", 2);  // forwards the arguments so the object can be created directly in the vector (no copy made)

	// push_back won't use explicit constructors, emplace_back will
	stack.push_back({ 2 }); // compile error: Foo(int) is explicit
	stack.emplace_back(2);  // ok

	return 0;
}
#+end_src

Prefer emplace_back() when creating a new temporary object to add to the container, or when you need to access an explicit constructor.
Prefer push_back() otherwise.

** std::vector<bool>
The modern consensus is that std::vector<bool> should generally be avoided, as the performance gains are unlikely to be worth the incompatibility headaches due to it not being a proper container.

Favor constexpr std::bitset, std::vector<char>, or 3rd party dynamic bitsets over std::vector<bool>.
* Fixed-size arrays: std::array and C-style arrays
** Introduction to std::array
Use std::array for constexpr arrays, and std::vector for non-constexpr arrays.
Perhaps surprisingly, a std::array can be defined with a length of 0.

Define your std::array as constexpr whenever possible. If your std::array is not constexpr, consider using a std::vector instead.

Use class template argument deduction (CTAD) to have the compiler deduce the type and length of a std::array from its initializers.
*** Omitting just the array length using std::to_array
#+begin_src cpp
#include <array>
#include <iostream>

int main()
{
    constexpr auto myArray1 { std::to_array<int, 5>({ 9, 7, 5, 3, 1 }) }; // Specify type and size
    constexpr auto myArray2 { std::to_array<int>({ 9, 7, 5, 3, 1 }) };    // Specify type only, deduce size
    constexpr auto myArray3 { std::to_array({ 9, 7, 5, 3, 1 }) };         // Deduce type and size

    return 0;
}
#+end_src
Unfortunately, using std::to_array is more expensive than creating a std::array directly, because it involves creation of a temporary std::array that is then used to copy initialize our desired std::array. For this reason, std::to_array should only be used in cases where the type can’t be effectively determined from the initializers, and should be avoided when an array is created many times (e.g. inside a loop).
** std::array of class types, and brace elision
When initializing a std::array with a struct, class, or array and not providing the element type with each initializer, you’ll need an extra pair of braces so that the compiler will properly interpret what to initialize.

This is an artifact of aggregate initialization, and other standard library container types (that use list constructors) do not require the double braces in these cases.
** Arrays of references via std::reference_wrapper
*** std::reference_wrapper
std::reference_wrapper is a standard library class template that lives in the <functional> header. It takes a type template argument T, and then behaves like a modifiable lvalue reference to T.

#+begin_src cpp
std::reference_wrapper ref1 { x };        // C++17
auto ref2 { std::reference_wrapper{ x }}; // C++17
#+end_src

*** std::ref and std::cref
#+begin_src cpp
int x { 5 };
auto ref { std::ref(x) };   // C++11, deduces to std::reference_wrapper<int>
auto cref { std::cref(x) }; // C++11, deduces to std::reference_wrapper<const int>
#+end_src
** Introduction to C-style arrays
Prefer omitting the length of a C-style array when explicitly initializing every array element with a value.
** C-style array decay
A function parameter expecting a C-style array type should use the array syntax (e.g. int arr[]) rather than pointer syntax (e.g. int *arr).

Avoid C-style arrays whenever practical.
Prefer std::string_view for read-only strings (string literal symbolic constants and string parameters).
Prefer std::string for modifiable strings.
Prefer std::array for non-global constexpr arrays.
Prefer std::vector for non-constexpr arrays.
It is okay to use C-style arrays for global constexpr arrays.
** Pointer arithmetic and subscripting
Favor subscripting when indexing from the start of the array (element 0), so the array indices line up with the element.

Favor pointer arithmetic when doing relative positioning from a given element.
** C-style strings
Avoid non-const C-style string objects in favor of std::string.
*** Inputting C-style strings
#+begin_src cpp :main no
#include <iostream>
#include <iterator> // for std::size

int main()
{
    char rolls[255] {}; // declare array large enough to hold 254 characters + null terminator
    std::cout << "Enter your rolls: ";
    std::cin.getline(rolls, std::size(rolls));
    std::cout << "You entered: " << rolls << '\n';

    return 0;
}
#+end_src
*** Getting the length of an C-style string
Use the strlen() function, which lives in the <cstring> header.
*** Other C-style string manipulating functions
- strlen() -- returns the length of a C-style string
- strcpy(), strncpy(), strcpy_s() -- overwrites one C-style string with another
- strcat(), strncat() -- Appends one C-style string to the end of another
- strcmp(), strncmp() -- Compares two C-style strings (returns 0 if equal)

Except for strlen(), we generally recommend avoiding these.
** C-style string symbolic constants
Avoid C-style string symbolic constants in favor of constexpr std::string_view.
** Multidimensional C-style Arrays
An initialized multidimensional array can omit (only) the leftmost length specification.
** Multidimensional std::array
#+begin_src cpp :main no
#include <array>
#include <iostream>

// An alias template for a two-dimensional std::array
template <typename T, std::size_t Row, std::size_t Col>
using Array2d = std::array<std::array<T, Col>, Row>;

// Fetch the number of rows from the Row non-type template parameter
template <typename T, std::size_t Row, std::size_t Col>
constexpr int rowLength(const Array2d<T, Row, Col>&) // you can return std::size_t if you prefer
{
    return Row;
}

// Fetch the number of cols from the Col non-type template parameter
template <typename T, std::size_t Row, std::size_t Col>
constexpr int colLength(const Array2d<T, Row, Col>&) // you can return std::size_t if you prefer
{
    return Col;
}

int main()
{
    // Define a two-dimensional array of int with 3 rows and 4 columns
    Array2d<int, 3, 4> arr {{
        { 1, 2, 3, 4 },
        { 5, 6, 7, 8 },
        { 9, 10, 11, 12 }}};

    std::cout << "Rows: " << rowLength(arr) << '\n'; // get length of first dimension (rows)
    std::cout << "Cols: " << colLength(arr) << '\n'; // get length of second dimension (cols)

    return 0;
}
#+end_src
** Multidimensional std::array
Introduced in C++23, std::mdspan is a modifiable view that provides a multidimensional array interface for a contiguous sequence of elements.
#+begin_src cpp :main no
#include <array>
#include <iostream>
#include <mdspan>

// An alias template to allow us to define a one-dimensional std::array using two dimensions
template <typename T, std::size_t Row, std::size_t Col>
using ArrayFlat2d = std::array<T, Row * Col>;

int main()
{
    // Define a one-dimensional std::array of int (with 3 rows and 4 columns)
    ArrayFlat2d<int, 3, 4> arr {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12 };

    // Define a two-dimensional span into our one-dimensional array
    // We must pass std::mdspan a pointer to the sequence of elements
    // which we can do via the data() member function of std::array or std::vector
    std::mdspan mdView { arr.data(), 3, 4 };

    // print array dimensions
    // std::mdspan calls these extents
    std::size_t rows { mdView.extents().extent(0) };
    std::size_t cols { mdView.extents().extent(1) };
    std::cout << "Rows: " << rows << '\n';
    std::cout << "Cols: " << cols << '\n';

    // print array in 1d
    // The data_handle() member gives us a pointer to the sequence of elements
    // which we can then index
    for (std::size_t i=0; i < mdView.size(); ++i)
        std::cout << mdView.data_handle()[i] << ' ';
    std::cout << '\n';

    // print array in 2d
    // We use multidimensional [] to access elements
    for (std::size_t row=0; row < rows; ++row)
    {
        for (std::size_t col=0; col < cols; ++col)
            std::cout << mdView[row, col] << ' ';
        std::cout << '\n';
    }
    std::cout << '\n';

    return 0;
}
#+end_src
* Iterators and Algorithms (under construction)
** Introduction to iterators
Using operator< was preferred over operator!= when doing numeric comparisons in the loop condition.
With iterators, it is conventional to use operator!= to test whether the iterator has reached the end element.
** Introduction to standard library algorithms
Before using a particular algorithm, make sure performance and execution order guarantees work for your particular use case.
Favor using functions from the algorithms library over writing your own functionality to do the same thing.
** Timing your code
Make sure you’re using a release build target, not a debug build target. Debug build targets typically turn optimization off, and that optimization can have a significant impact on the results.
#+begin_src cpp :main no
#include <algorithm> // for std::sort
#include <array>
#include <chrono> // for std::chrono functions
#include <cstddef> // for std::size_t
#include <iostream>
#include <numeric> // for std::iota

const int g_arrayElements { 10000 };

class Timer
{
private:
    // Type aliases to make accessing nested type easier
    using Clock = std::chrono::steady_clock;
    using Second = std::chrono::duration<double, std::ratio<1> >;

    std::chrono::time_point<Clock> m_beg{ Clock::now() };

public:

    void reset()
    {
        m_beg = Clock::now();
    }

    double elapsed() const
    {
        return std::chrono::duration_cast<Second>(Clock::now() - m_beg).count();
    }
};

int main()
{
    std::array<int, g_arrayElements> array;
    std::iota(array.rbegin(), array.rend(), 1); // fill the array with values 10000 to 1

    Timer t;

    std::ranges::sort(array); // Since C++20
    // If your compiler isn't C++20-capable
    // std::sort(array.begin(), array.end());

    std::cout << "Time taken: " << t.elapsed() << " seconds\n";

    return 0;
}
#+end_src
* Dynamic Allocation (under construction)
** Dynamic memory allocation with new and delete
#+begin_src cpp
int* ptr1{ new int (5) }; // use direct initialization
int* ptr2{ new int { 6 } }; // use uniform initialization

// assume ptr has previously been allocated with operator new
delete ptr; // return the memory pointed to by ptr to the operating system
ptr = nullptr; // set ptr to be a null pointer
#+end_src
The delete operator does not actually delete anything. It simply returns the memory being pointed to back to the operating system. The operating system is then free to reassign that memory to another application (or to this application again later).

Although it looks like we’re deleting a variable, this is not the case! The pointer variable still has the same scope as before, and can be assigned a new value just like any other variable.

Note that deleting a pointer that is not pointing to dynamically allocated memory may cause bad things to happen.

Set deleted pointers to nullptr unless they are going out of scope immediately afterward.
*** Operator new can fail
#+begin_src cpp
int* value { new (std::nothrow) int{} }; // ask for an integer's worth of memory
if (!value) // handle case where new returned null
{
    // Do error handling here
    std::cerr << "Could not allocate memory\n";
}
#+end_src
*** Null pointers and dynamic memory allocation
Deleting a null pointer is okay, and does nothing. There is no need to conditionalize your delete statements.
*** Memory leaks
Avoided by ensuring you delete the pointer before reassigning.
** Dynamically allocating arrays
While you can dynamically allocate a std::array, you’re usually better off using a non-dynamically allocated std::vector in this case.
#+begin_src cpp
int fixedArray[5] = { 9, 7, 5, 3, 1 }; // initialize a fixed array before C++11
int* array{ new int[5]{ 9, 7, 5, 3, 1 } }; // initialize a dynamic array since C++11
// To prevent writing the type twice, we can use auto. This is often done for types with long names.
auto* array{ new int[5]{ 9, 7, 5, 3, 1 } };

delete[] array; // use array delete to deallocate array
#+end_src
** Pointers to pointers and dynamic multidimensional arrays
*** Two-dimensional dynamically allocated arrays
**** If the rightmost array dimension is constexpr, you can do this:
#+begin_src cpp
int x { 7 }; // non-constant
auto array { new int[x][5] }; // rightmost dimension must be constexpr
#+end_src
**** triangle-shaped array
#+begin_src cpp
int** array { new int*[10] }; // allocate an array of 10 int pointers — these are our rows
for (int count { 0 }; count < 10; ++count)
    array[count] = new int[count+1]; // these are our columns

for (int count { 0 }; count < 10; ++count)
    delete[] array[count];
delete[] array; // this needs to be done last
#+end_src
** Void pointers
The void pointer, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type! A void pointer is declared like a normal pointer, using the void keyword as the pointer’s type:
#+begin_src cpp
void* ptr {}; // ptr is a void pointer
#+end_src
However, because the void pointer does not know what type of object it is pointing to, dereferencing a void pointer is illegal. Instead, the void pointer must first be cast to another pointer type before the dereference can be performed.
#+begin_src cpp
int value{ 5 };
void* voidPtr{ &value };

// std::cout << *voidPtr << '\n'; // illegal: dereference of void pointer

int* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...

std::cout << *intPtr << '\n'; // then we can dereference the result
#+end_src

If a void pointer doesn’t know what it’s pointing to, how do we know what to cast it to? Ultimately, that is up to you to keep track of.

#+begin_src cpp
#include <cassert>
#include <iostream>

enum class Type
{
    tInt, // note: we can't use "int" here because it's a keyword, so we'll use "tInt" instead
    tFloat,
    tCString
};

void printValue(void* ptr, Type type)
{
    switch (type)
    {
    case Type::tInt:
        std::cout << *static_cast<int*>(ptr) << '\n'; // cast to int pointer and perform indirection
        break;
    case Type::tFloat:
        std::cout << *static_cast<float*>(ptr) << '\n'; // cast to float pointer and perform indirection
        break;
    case Type::tCString:
        std::cout << static_cast<char*>(ptr) << '\n'; // cast to char pointer (no indirection)
        // std::cout will treat char* as a C-style string
        // if we were to perform indirection through the result, then we'd just print the single char that ptr is pointing to
        break;
    default:
        std::cerr << "printValue(): invalid type provided\n";
        assert(false && "type not found");
        break;
    }
}

int main()
{
    int nValue{ 5 };
    float fValue{ 7.5f };
    char szValue[]{ "Mollie" };

    printValue(&nValue, Type::tInt);
    printValue(&fValue, Type::tFloat);
    printValue(szValue, Type::tCString);

    return 0;
}
#+end_src

Avoid using void pointers unless absolutely necessary, as they effectively allow you to avoid type checking.
* Functions
** Function Pointers
#+begin_src cpp
// fcnPtr is a pointer to a function that takes no arguments and returns an integer
int (*fcnPtr)();
int (*const fcnPtr)();
#+end_src
*** Assigning a function to a function pointer
#+begin_src cpp
// function prototypes
int foo();
double goo();
int hoo(int x);

// function pointer initializers
int (*fcnPtr1)(){ &foo };    // okay
int (*fcnPtr2)(){ &goo };    // wrong -- return types don't match!
double (*fcnPtr4)(){ &goo }; // okay
fcnPtr1 = &hoo;              // wrong -- fcnPtr1 has no parameters, but hoo() does
int (*fcnPtr3)(int){ &hoo }; // okay
#+end_src
*** Calling a function using a function pointer
#+begin_src cpp
int foo(int x)
{
    return x;
}

int main()
{
    int (*fcnPtr)(int){ &foo }; // Initialize fcnPtr with function foo
    if (fcnPtr) // make sure fcnPtr isn't a null pointer
        fcnPtr(5); // otherwise this will lead to undefined behavior

    return 0;
}
#+end_src
*** Default arguments don’t work for functions called through function pointers 
Because the resolution happens at runtime, default arguments are not resolved when a function is called through a function pointer.
*** Passing functions as arguments to other functions
#+begin_src cpp
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))
void selectionSort(int* array, int size, bool comparisonFcn(int, int))
  // Default the sort to ascending sort
void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int) = ascending);
#+end_src
*** Making function pointers prettier with type aliases
#+begin_src cpp
using ValidateFunction = bool(*)(int, int);
bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly
bool validate(int x, int y, ValidateFunction pfcn) // clean
#+end_src
*** Using std::function
#+begin_src cpp
#include <functional>
bool validate(int x, int y, std::function<bool(int, int)> fcn); // std::function method that returns a bool and takes two int parameters
#+end_src
** The stack and the heap
The memory that a program uses is typically divided into a few different areas, called segments:

The code segment (also called a text segment), where the compiled program sits in memory. The code segment is typically read-only.
The bss segment (also called the uninitialized data segment), where zero-initialized global and static variables are stored.
The data segment (also called the initialized data segment), where initialized global and static variables are stored.
The heap, where dynamically allocated variables are allocated from.
The call stack, where function parameters, local variables, and other function-related information are stored.
*** The heap segment
Allocating memory on the heap is comparatively slow.
Allocated memory stays allocated until it is specifically deallocated (beware memory leaks) or the application ends (at which point the OS should clean it up).
Dynamically allocated memory must be accessed through a pointer. Dereferencing a pointer is slower than accessing a variable directly.
Because the heap is a big pool of memory, large arrays, structures, or classes can be allocated here.
*** The call stack segment
Allocating memory on the stack is comparatively fast.
Memory allocated on the stack stays in scope as long as it is on the stack. It is destroyed when it is popped off the stack.
All memory allocated on the stack is known at compile time. Consequently, this memory can be accessed directly through a variable.
Because the stack is relatively small, it is generally not a good idea to do anything that eats up lots of stack space. This includes allocating or copying large arrays or other memory-intensive structures.
*** The call stack in action
When the function terminates, the following steps happen:
1. Registers are restored from the call stack
2. The stack frame is popped off the stack. This frees the memory for all local variables and arguments.
3. The return value is handled.
4. The CPU resumes execution at the return address.
*** Stack overflow
Stack overflow happens when all the memory in the stack has been allocated.
** Recursion
Generally favor iteration over recursion, except when recursion really makes sense.
** Command line arguments
*** Dealing with numeric arguments
#+begin_src cpp :main no
#include <iostream>
#include <sstream> // for std::stringstream
#include <string>

int main(int argc, char* argv[])
{
	if (argc <= 1)
	{
		// On some operating systems, argv[0] can end up as an empty string instead of the program's name.
		// We'll conditionalize our response on whether argv[0] is empty or not.
		if (argv[0])
			std::cout << "Usage: " << argv[0] << " <number>" << '\n';
		else
			std::cout << "Usage: <program name> <number>" << '\n';

		return 1;
	}

	std::stringstream convert{ argv[1] }; // set up a stringstream variable named convert, initialized with the input from argv[1]

	int myint{};
	if (!(convert >> myint)) // do the conversion
		myint = 0; // if conversion fails, set myint to a default value

	std::cout << "Got integer: " << myint << '\n';

	return 0;
}
#+end_src
** Ellipsis (and why to avoid them)
#+begin_src cpp :main no
#include <iostream>
#include <cstdarg> // needed to use ellipsis

// The ellipsis must be the last parameter
// count is how many additional arguments we're passing
double findAverage(int count, ...)
{
    int sum{ 0 };

    // We access the ellipsis through a va_list, so let's declare one
    std::va_list list;

    // We initialize the va_list using va_start.  The first argument is
    // the list to initialize.  The second argument is the last non-ellipsis
    // parameter.
    va_start(list, count);

    // Loop through all the ellipsis values
    for (int arg{ 0 }; arg < count; ++arg)
    {
         // We use va_arg to get values out of our ellipsis
         // The first argument is the va_list we're using
         // The second argument is the type of the value
         sum += va_arg(list, int);
    }

    // Cleanup the va_list when we're done.
    va_end(list);

    return static_cast<double>(sum) / count;
}

int main()
{
    std::cout << findAverage(5, 1, 2, 3, 4, 5) << '\n';
    std::cout << findAverage(6, 1, 2, 3, 4, 5, 6) << '\n';

    return 0;
}
#+end_src
*** ellipsis are dangerous: 
Type checking is suspended
ellipsis don’t know how many parameters were passed
*** fold expression
Maybe check later.
** Introduction to lambdas (anonymous functions)
Following the best practice of defining things in the smallest scope and closest to first use, lambdas are preferred over normal functions when we need a trivial, one-off function to pass as an argument to some other function.

When storing a lambda in a variable, use auto as the variable’s type.
** Lambda captures
Lambdas can only access certain kinds of objects that have been defined outside the lambda, including those with static storage duration (e.g. global variables and static locals) and constexpr objects.

Captures are treated as const by default.
Mutable captures copy a modifiable variable, but not change source. Because captured variables are members of the lambda object, their values are persisted across multiple calls to the lambda!
Capture by reference modify source value, unless const.
*** Default captures
To capture all used variables by value, use a capture value of =.
To capture all used variables by reference, use a capture value of &.

#+begin_src cpp
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// Capture health and armor by value, and enemies by reference.
[health, armor, &enemies](){};

// Capture enemies by reference and everything else by value.
[=, &enemies](){};

// Capture armor by value and everything else by reference.
[&, armor](){};

// Illegal, we already said we want to capture everything by reference.
[&, &armor](){};

// Illegal, we already said we want to capture everything by value.
[=, armor](){};

// Illegal, armor appears twice.
[armor, &health, &armor](){};

// Illegal, the default capture has to be the first element in the capture group.
[armor, &](){};
#+end_src
*** Defining new variables in the lambda-capture
Only initialize variables in the capture if their value is short and their type is obvious. Otherwise it’s best to define the variable outside of the lambda and capture it.
#+begin_src cpp
#include <array>
#include <iostream>
#include <algorithm>

int main()
{
  std::array areas{ 100, 25, 121, 40, 56 };

  int width{};
  int height{};

  std::cout << "Enter width and height: ";
  std::cin >> width >> height;

  // We store areas, but the user entered width and height.
  // We need to calculate the area before we can search for it.
  auto found{ std::find_if(areas.begin(), areas.end(),
                           // Declare a new variable that's visible only to the lambda.
                           // The type of userArea is automatically deduced to int.
                           [userArea{ width * height }](int knownArea) {
                             return userArea == knownArea;
                           }) };

  if (found == areas.end())
  {
    std::cout << "I don't know this area :(\n";
  }
  else
  {
    std::cout << "Area found :)\n";
  }

  return 0;
}
#+end_src
*** Dangling captured variables
Be extra careful when you capture variables by reference, especially with a default reference capture. The captured variables must outlive the lambda.

*** Unintended copies of mutable lambdas 
Standard library functions may copy function objects (reminder: lambdas are function objects). If you want to provide lambdas with mutable captured variables, pass them by reference using std::ref.

Try to avoid mutable lambdas. Non-mutable lambdas are easier to understand and don’t suffer from the above issues, as well as more dangerous issues that arise when you add parallel execution.
* Operator Overloading
** Introduction to operator overloading
An overloaded operator should operate on at least one program-defined type (either as a parameter of the function, or the implicit object).
When overloading operators, it’s best to keep the function of the operators as close to the original intent of the operators as possible.
If the meaning of an overloaded operator is not clear and intuitive, use a named function instead.

Operators that do not modify their operands (e.g. arithmetic operators) should generally return results by value.
Operators that modify their leftmost operand (e.g. pre-increment, any of the assignment operators) should generally return the leftmost operand by reference.
** Overloading operators using normal functions
Prefer overloading operators as normal functions instead of friends if it’s possible to do so without adding additional functions.
** Overloading operators using member functions
*** Not everything can be overloaded as a friend function
The assignment (=), subscript ([]), function call (()), and member selection (->) operators must be overloaded as member functions, because the language requires them to be.
*** Not everything can be overloaded as a member function
<< 
*** When to use a normal, friend, or member function overload
- If you’re overloading assignment (=), subscript ([]), function call (()), or member selection (->), do so as a member function.
- If you’re overloading a unary operator, do so as a member function.
- If you’re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function (preferred) or friend function.
- If you’re overloading a binary operator that modifies its left operand, but you can’t add members to the class definition of the left operand (e.g. operator<<, which has a left operand of type ostream), do so as a normal function (preferred) or friend function.
- If you’re overloading a binary operator that modifies its left operand (e.g. operator+=), and you can modify the definition of the left operand, do so as a member function.
** Overloading the comparison operators
Only define overloaded operators that make intuitive sense for your class.
*** Minimizing comparative redundancy
- operator!= can be implemented as !(operator==)
- operator> can be implemented as operator< with the order of the parameters flipped
- operator>= can be implemented as !(operator<)
- operator<= can be implemented as !(operator>)
#+begin_src cpp :main no
#include <iostream>

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents& c1, const Cents& c2) { return c1.m_cents == c2.m_cents; }
    friend bool operator!= (const Cents& c1, const Cents& c2) { return !(operator==(c1, c2)); }

    friend bool operator< (const Cents& c1, const Cents& c2) { return c1.m_cents < c2.m_cents; }
    friend bool operator> (const Cents& c1, const Cents& c2) { return operator<(c2, c1); }

    friend bool operator<= (const Cents& c1, const Cents& c2) { return !(operator>(c1, c2)); }
    friend bool operator>= (const Cents& c1, const Cents& c2) { return !(operator<(c1, c2)); }

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel > dime)
        std::cout << "a nickel is greater than a dime.\n";
    if (nickel >= dime)
        std::cout << "a nickel is greater than or equal to a dime.\n";
    if (nickel < dime)
        std::cout << "a dime is greater than a nickel.\n";
    if (nickel <= dime)
        std::cout << "a dime is greater than or equal to a nickel.\n";
    if (nickel == dime)
        std::cout << "a dime is equal to a nickel.\n";
    if (nickel != dime)
        std::cout << "a dime is not equal to a nickel.\n";

    return 0;
}
#+end_src
*** The spaceship operator <=>
C++20 introduces the spaceship operator (operator<=>), which allows us to reduce the number of comparison functions we need to write down to 2 at most, and sometimes just 1!
** Overloading the increment and decrement operators
Overloaded as member functions.
If the overloaded operator has an int parameter, the operator is a postfix overload. If the overloaded operator has no parameter, the operator is a prefix overload.
** Overloading the subscript operator
Must be overloaded as a member function.
C++23 adds support for overloading operator[] with multiple subscripts.
Operator[] returns a reference

*** Overloaded operator[] for const objects
We can define a non-const and a const version of operator[] separately. The non-const version will be used with non-const objects, and the const version with const-objects.

*** Removing duplicate code between const and non-const overloads
#+begin_src cpp :main no
#include <iostream>
#include <utility> // for std::as_const

class IntList
{
private:
  int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // give this class some initial state for this example

public:
  // Use an explicit object parameter (self) and auto&& to differentiate const vs non-const
  auto&& operator[](this auto&& self, int index)
  {
    // Complex code goes here
    return self.m_list[index];
  }
  // C23 above

  int& operator[] (int index)
  {
    // use std::as_const to get a const version of `this` (as a reference)
    // so we can call the const version of operator[]
    // then const_cast to discard the const on the returned reference
    return const_cast<int&>(std::as_const(*this)[index]);
  }

  const int& operator[] (int index) const
  {
    return m_list[index];
  }
};

int main()
{
  IntList list{};
  list[2] = 3; // okay: calls non-const version of operator[]
  std::cout << list[2] << '\n';

  const IntList clist{};
  // clist[2] = 3; // compile error: clist[2] returns const refrence, which we can't assign to
  std::cout << clist[2] << '\n';

  return 0;
}
#+end_src

*** Detecting index validity
#+begin_src cpp
#include <cassert> // for assert()
#include <iterator> // for std::size()

class IntList
{
private:
    int m_list[10]{};

public:
    int& operator[] (int index)
    {
        assert(index >= 0 && static_cast<std::size_t>(index) < std::size(m_list));

        return m_list[index];
    }
};
#+end_src

*** Pointers to objects and overloaded operator[] don’t mix
Make sure you’re not trying to call an overloaded operator[] on a pointer to an object.

*** The function parameter does not need to be an integral type
You can define that your overloaded operator[] take a value of any type you desire. You could define your overloaded operator[] to take a double, a std::string, or whatever else you like.

** Overloading the parenthesis operator
#+begin_src cpp
#include <cassert> // for assert()
class Matrix
{
private:
    double m_data[4][4]{};

public:
    double& operator()(int row, int col);
    double operator()(int row, int col) const;
    void operator()();
};

double& Matrix::operator()(int row, int col)
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}

double Matrix::operator()(int row, int col) const
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}

void Matrix::operator()()
{
    // reset all elements of the matrix to 0.0
    for (int row{ 0 }; row < 4; ++row)
    {
        for (int col{ 0 }; col < 4; ++col)
        {
            m_data[row][col] = 0.0;
        }
    }
}
#+end_src
Operator() is sometimes overloaded with two parameters to index multidimensional arrays, or to retrieve a subset of a one dimensional array (with the two parameters defining the subset to return). Anything else is probably better written as a member function with a more descriptive name.

Operator() is also often overloaded to create functors. Although simple functors (such as the example above) are fairly easily understood, functors are typically used in more advanced programming topics, and deserve their own lesson.

** Overloading typecasts
Typecasts should be marked as explicit, except in cases where the class to be converted to is essentially synonymous.
#+begin_src cpp :main no
#include <iostream>

class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents=0)
        : m_cents{ cents }
    {
    }

    explicit operator int() const { return m_cents; } // now marked as explicit

    int getCents() const { return m_cents; }
    void setCents(int cents) { m_cents = cents; }
};

class Dollars
{
private:
    int m_dollars{};
public:
    Dollars(int dollars=0)
        : m_dollars{ dollars }
    {
    }

    operator Cents() const { return Cents { m_dollars * 100 }; }
};

void printCents(Cents cents)
{
    std::cout << static_cast<int>(cents); // must use explicit cast to invoke explicit typecast
}

int main()
{
    Dollars dollars{ 9 };
    printCents(dollars);

    std::cout << '\n';

    return 0;
}
#+end_src

*** Converting constructors vs overloaded typecasts 
In general, a converting constructor should be preferred to an overloaded typecast, as it allows the type being constructed to own the construction.

There are a few cases where an overloaded typecast should be used instead:

- When providing a conversion to a fundamental type (since you can’t define constructors for these types). Most idiomatically, these are used to provide a conversion to bool for cases where it makes sense to be able to use an object in a conditional statement.
- When providing a conversion to a type you can’t add members to (e.g. a conversion to std::vector, since you can’t define constructors for these types either).
- When you do not want the type being constructed to be aware of the type being converted from. This can be helpful for avoiding circular dependencies.

For an example of that last bullet, std::string has a constructor to create a std::string from a std::string_view. This means <string> must include <string_view>. If std::string_view had a constructor to create a std::string_view from a std::string, then <string_view> would need to include <string>, and this would result in a circular dependency between headers.

Instead, std::string has an overloaded typecast that handles conversion from std::string to std::string_view (which is fine, since it’s already including <string_view>). std::string_view does not know about std::string at all, and thus does not need to include <string>. In this way, the circular dependency is avoided.


** Overloading the assignment operator
*** Copy assignment vs Copy constructor
- If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).
- If a new object does not have to be created before the copying can occur, the assignment operator is used.
*** Detecting and handling self-assignment
#+begin_src cpp
MyString& MyString::operator= (const MyString& str)
{
	// self-assignment check
	if (this == &str)
		return *this;

	// if data exists in the current string, delete it
	if (m_data) delete[] m_data;

	m_length = str.m_length;
	m_data = nullptr;

	// allocate a new array of the appropriate length
	if (m_length)
		m_data = new char[static_cast<std::size_t>(str.m_length)];

	std::copy_n(str.m_data, m_length, m_data); // copies m_length elements of str.m_data into m_data

	// return the existing object so we can chain this operator
	return *this;
}
#+end_src
** Shallow vs. deep copying
*** Shallow copying
Because C++ does not know much about your class, the default copy constructor and default assignment operators it provides use a copying method known as a memberwise copy (also known as a shallow copy). This means that C++ copies each member of the class individually (using the assignment operator for overloaded operator=, and direct initialization for the copy constructor). When classes are simple (e.g. do not contain any dynamically allocated memory), this works very well.
*** Deep copying
One answer to this problem is to do a deep copy on any non-null pointers being copied. A deep copy allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source. This way, the copy and source are distinct and will not affect each other in any way. Doing deep copies requires that we write our own copy constructors and overloaded assignment operators.
#+begin_src cpp
// assumes m_data is initialized
void MyString::deepCopy(const MyString& source)
{
    // first we need to deallocate any value that this string is holding!
    delete[] m_data;

    // because m_length is not a pointer, we can shallow copy it
    m_length = source.m_length;

    // m_data is a pointer, so we need to deep copy it if it is non-null
    if (source.m_data)
    {
        // allocate memory for our copy
        m_data = new char[m_length];

        // do the copy
        for (int i{ 0 }; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = nullptr;
}

// Copy constructor
MyString::MyString(const MyString& source)
{
    deepCopy(source);
}

// Assignment operator
MyString& MyString::operator=(const MyString& source)
{
    // check for self-assignment
    if (this != &source)
    {
        // now do the deep copy
        deepCopy(source);
    }

    return *this;
}
#+end_src
*** The rule of three
Remember the rule of three? If a class requires a user-defined destructor, copy constructor, or copy assignment operator, then it probably requires all three. This is why. If we’re user-defining any of these functions, it’s probably because we’re dealing with dynamic memory allocation. We need the copy constructor and copy assignment to handle deep copies, and the destructor to deallocate memory.
*** A better solution
Classes in the standard library that deal with dynamic memory, such as std::string and std::vector, handle all of their memory management, and have overloaded copy constructors and assignment operators that do proper deep copying. So instead of doing your own memory management, you can just initialize or assign them like normal fundamental variables! That makes these classes simpler to use, less error-prone, and you don’t have to spend time writing your own overloaded functions!
*** Summary
- The default copy constructor and default assignment operators do shallow copies, which is fine for classes that contain no dynamically allocated variables.
- Classes with dynamically allocated variables need to have a copy constructor and assignment operator that do a deep copy.
- Favor using classes in the standard library over doing your own memory management.
* Next
https://www.learncpp.com/cpp-tutorial/chapter-21-project/
