* Basic
** Initialization
https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/

Prefer list or value initialization.

#+begin_src cpp
int a;         // no initializer                            (default initialization)
int b = 5;     // initial value after equals sign           (copy initialization)
int c( 6 );    // initial value in parenthesis              (direct initialization)

// List initialization methods                              (C++11) (preferred)
int d { 7 };   // initial value in braces                   (direct list initialization)
int e = { 8 }; // initial value in braces after equals sign (copy list initialization)
int f {};      // initializer is empty braces               (value initialization)
#+end_src

*** multiple init
#+begin_src cpp
int a = 5, b = 6;          // copy initialization
int c( 7 ), d( 8 );        // direct initialization
int e { 9 }, f { 10 };     // direct brace initialization
int g = { 9 }, h = { 10 }; // copy brace initialization
int i {}, j {};            // value initialization
#+end_src

use [[maybe_unused]​] attribute to avoid error, via abbrev.

** iostream
Prefer \n over std::endl when outputting text to the console.


* Function and File
** Return value
If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.
#+begin_src cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
#+end_src

** Comment unused function parameter
When a function parameter exists but is not used in the body of the function, do not give it a name. You can optionally put a name inside a comment.
#+begin_src cpp
void doSomething(int /*count*/)
{
}
#+end_src

** Define variable
Define your local variables as close to their first use as reasonable.

** Preprocessor
The entire process of preprocessing, compiling, and linking is called translation.

Preprocessor doesn’t understand C++ concepts.

Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one file do not have any impact on other files (unless they are #included into another file).


** Header
Source files should #include their paired header file (if one exists).

Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.

Use the standard library header files without the .h extension. User-defined headers should still use a .h extension.

Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

*** #include order
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

That way, if one of your user-defined headers is missing an #include for a 3rd party library or standard library header, it’s more likely to cause a compile error so you can fix it.

** Header Guard
Beware two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\config.h and directoryB\config.h).

** Design and Implementation

*** Design step
**** Define goal
It is often useful to express this as a user-facing outcome. For example:

1. Allow the user to organize a list of names and associated phone numbers.
2. Generate randomized dungeons that will produce interesting looking caverns.
3. Generate a list of stock recommendations for stocks that have high dividends.
4. Model how long it takes for a ball dropped off a tower to hit the ground.
**** Define requirements
Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc…), as well as the capabilities that the program must exhibit in order to meet the users’ needs. Note that your requirements should similarly be focused on the “what”, not the “how”. For example:

- Phone numbers should be saved, so they can be recalled later.
- The randomized dungeon should always contain a way to get from the entrance to an exit.
- The stock recommendations should leverage historical pricing data.
- The user should be able to enter the height of the tower.
- We need a testable version within 7 days.
- The program should produce results within 10 seconds of the user submitting their request.
- The program should crash in less than 0.1% of user sessions.
**** Define your tools, targets, and backup plan
- Defining what target architecture and/or OS your program will run on.
- Determining what set of tools you will be using.
- Determining whether you will write your program alone or as part of a team.
- Defining your testing/feedback/release strategy.
- Determining how you will back up your code.
**** Break hard problems down into easy problems
The top level task becomes main() (because it is the main problem you are trying to solve). The subitems become functions in the program.
**** Figure out the sequence of events
If we were writing a calculator, we might do things in this order:

1. Get first number from user
2. Get mathematical operation from user
3. Get second number from user
4. Calculate result
5. Print result

At this point, we’re ready for implementation.

*** Implementation
**** Outlining your main function
#+begin_src cpp
int main()
{
    // Get first number from user
//    getUserInput();

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Implement each function
1. Define the function prototype (inputs and outputs)
2. Write the function
3. Test the function
#+begin_src cpp
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Final testing
Once your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.

*** Words of advice when writing programs

**** Keep your programs simple to start
Often new programmers have a grand vision for all the things they want their program to do. “I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon”. If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress. Instead, make your first goal as simple as possible, something that is definitely within your reach. For example, “I want to be able to display a 2-dimensional field on the screen”.



**** Add features over time
Once you have your simple program working and working well, then you can add features to it. For example, once you can display your field, add a character who can walk around. Once you can walk around, add walls that can impede your progress. Once you have walls, build a simple town out of them. Once you have a town, add merchants. By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.

**** Focus on one area at a time
New programmers will often write the entire program in one pass. Then when they compile it for the first time, the compiler reports hundreds of errors. This can not only be intimidating, if your code doesn’t work, it may be hard to figure out why. Instead, write a piece of code, and then compile and test it immediately. If it doesn’t work, you’ll know exactly where the problem is, and it will be easy to fix. Once you are sure that the code works, move to the next piece and repeat. It may take longer to finish writing your code, but when you are done the whole thing should work, and you won’t have to spend twice as long trying to figure out why it doesn’t.

**** Don’t invest in perfecting early code
The first draft of a feature (or program) is rarely good. Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things. If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary. Instead, get your features minimally working and then move on. As you gain confidence in your solutions, apply successive layers of polish. Don’t aim for perfect -- non-trivial programs are never perfect, and there’s always something more that could be done to improve them. Get to “good enough” and move on.



**** Optimize for maintainability, not performance
There is a famous quote (by Donald Knuth) that says “premature optimization is the root of all evil”. New programmers often spend far too much time thinking about how to micro-optimize their code (e.g. trying to figure out which of 2 statements is faster). This rarely matters. Most performance benefits come from good program structure, using the right tools and capabilities for the problem at hand, and following best practices. Additional time should be used to improve the maintainability of your code. Find redundancy and remove it. Split up long functions into shorter ones. Replace awkward or hard to use code with something better. The end result will be code that is easier to improve and optimize later (after you’ve determined where optimization is actually needed) and fewer bugs.



* Debug
** Step
1. Find the root cause of the problem (usually the line of code that’s not working).
2. Ensure you understand why the issue is occurring.
3. Determine how you’ll fix the issue.
4. Repair the issue causing the problem.
5. Retest to ensure the problem has been fixed.
6. Retest to ensure no new problems have emerged.

** Tactic

*** std::cerr instead of std::cout when debugging
cerr is unbufferd.

*** Debug with preprocessor
#+begin_src cpp
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging, or define in header file

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
#+end_src

*** Logger
Such as spdlog or plog.

** Refactor
Ideally, a function should be less than ten lines. Functions that are less than five lines are even better.

Remember that the goal here is to maximize comprehension and maintainability, not to minimize function length -- abandoning best practices or using obscure coding techniques to save a line or two doesn’t do your code any favors.

** Defensive programming
Defensive programming is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code. These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).

** unit testing
#+begin_src cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void testadd()
{
	std::cout << "This function should print: 2 0 0 -2\n";
	std::cout << add(1, 1) << ' ';
	std::cout << add(-1, 1) << ' ';
	std::cout << add(1, -1) << ' ';
	std::cout << add(-1, -1) << ' ';
}

int main()
{
	testadd();

	return 0;
}
#+end_src

* Fundamental Data Type
** Int
#+begin_src cpp
short s;      // prefer "short" instead of "short int"
int i;
long l;       // prefer "long" instead of "long int"
long long ll; // prefer "long long" instead of "long long int"
signed short ss;
signed int si;
signed long sl;
signed long long sll;
#+end_src
Prefer the shorthand types that do not use the int suffix or signed prefix.

*** Signed integer range
$-(2^(n-1))$ to $2^(n-1)-1$

If outside the range, then overflow.

*** Unsigned integer
Avoid unsigned integer.

Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.

**** when should you use unsigned numbers?
First, unsigned numbers are preferred when dealing with bit manipulation (covered in chapter O -- that’s a capital ‘o’, not a ‘0’). They are also useful when well-defined wrap-around behavior is required (useful in some algorithms like encryption and random number generation).

Second, use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing. We’ll talk more about this in the lessons on arrays and array indexing.

Also note that if you’re developing for an embedded system (e.g. an Arduino) or some other processor/memory limited context, use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.

*** fixed-width-integers and size_t

**** integer choice

***** Prefer

Prefer int when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer) and the variable is short-lived (e.g. destroyed at the end of the function). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
Prefer std::int#_t when storing a quantity that needs a guaranteed range.
Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required.

***** Avoid

short and long integers -- use a fixed-width type instead.
Unsigned types for holding quantities.
The 8-bit fixed-width integer types.
The fast and least fixed-width types.
Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…

**** size_t
std::size_t is an alias for an implementation-defined unsigned integral type. It is used within the standard library to represent the byte-size or length of objects.

If you use std::size_t explicitly in your code, #include one of the headers that defines std::size_t (we recommend <cstddef>).
Using sizeof does not require a header (even though it return a value whose type is std::size_t).
** Char
Avoid multicharacter literals (e.g. '56').
*** Other char type
wchar_t should be avoided in almost all cases (except when interfacing with the Windows API).

You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible.
*** Type Conversion and static_cast
Type conversion uses direct initialization to produce a new value of the target type from a value of a different type.

Prefer static_cast<type>(x)
* Constant and String
** Constant variable
Place const before the type (because it is more conventional to do so).
Don’t use const when passing by value.
Don’t use const when returning by value.
Prefer constant variables over object-like macros with substitution text.
** Literal
*** Type of literal
| Literal value        | Examples        | Default literal type | Note                                      |
|----------------------+-----------------+----------------------+-------------------------------------------|
| integer value        | 5, 0, -3        | int                  |                                           |
| boolean value        | true, false     | bool                 |                                           |
| floating point value | 1.2, 0.0, 3.4   | double (not float!)  |                                           |
| character            | ‘a’, ‘\n’       | char                 |                                           |
| C-style string       | “Hello, world!” | const char[14]       | see C-style string literals section below |
*** Literal suffixes
If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix. Here are some of the more common suffixes:
In most cases, suffixes aren’t needed (except for f).
| Data type      | Suffix                                 | Meaning                                   |
|----------------+----------------------------------------+-------------------------------------------|
| integral       | u or U                                 | unsigned int                              |
| integral       | l or L                                 | long                                      |
| integral       | ul, uL, Ul, UL, lu, lU, Lu, LU         | unsigned long                             |
| integral       | ll or LL                               | long long                                 |
| integral       | ull, uLL, Ull, ULL, llu, llU, LLu, LLU | unsigned long long                        |
| integral       | z or Z                                 | The signed version of std::size_t (C++23) |
| integral       | uz, uZ, Uz, UZ, zu, zU, Zu, ZU         | std::size_t (C++23)                       |
| floating point | f or F                                 | float                                     |
| floating point | l or L                                 | long double                               |
| string         | s                                      | std::string                               |
| string         | sv                                     | std::string_view                          |
Because lower-case L can look like numeric 1 in some fonts, some developers prefer to use upper-case literals. Others use lower case suffixes except for L.
*** String
C-style string literals are const objects that are created at the start of the program and are guaranteed to exist for the entirety of the program.
Unlike C-style string literals, std::string and std::string_view literals create temporary objects. These temporary objects must be used immediately, as they are destroyed at the end of the full expression in which they are created.
*** Magic number
A magic number is a literal (usually a number) that either has an unclear meaning or may need to be changed later.
Avoid magic numbers in your code (use constexpr variables instead).
** Number
| decimal | octal | hexdecimal | binary |
|---------+-------+------------+--------|
|       1 |    01 |        0x1 | 0b1    |
|      12 |   014 |        0xC | 0b1100 |

*** Seperator
#+begin_src cpp
int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
long value { 2'132'673'462 }; // much easier to read than 2132673462
int cin { 0b'1011'0010 };  // error: ' used before first digit of value
#+end_src

*** Output
#+begin_src cpp
int x { 12 };
std::cout << x << '\n'; // decimal (by default)
std::cout << std::hex << x << '\n'; // hexadecimal
std::cout << x << '\n'; // now hexadecimal
std::cout << std::oct << x << '\n'; // octal
std::cout << std::dec << x << '\n'; // return to decimal
std::cout << x << '\n'; // decimal
#+end_src
Note that once applied, the I/O manipulator remains set for future output until it is changed again.

binary
#+begin_src cpp :main no
#include <bitset> // for std::bitset
#include <iostream>

int main()
{
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it

	return 0;
}
#+end_src

**** Format and Print
#+begin_src cpp :main no
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} formats the argument as binary digits
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} formats the argument as 0b-prefixed binary digits

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, format/print two arguments (same as above) and a newline

    return 0;
}
#+end_src


** Constant expressions
The most common type of operators and functions that support compile-time evaluation include:

Arithmetic operators with operands that are compile-time constants (e.g. 1 + 2)
Constexpr and consteval functions (we’ll discuss these later in the chapter)

If the const variable has an integral type and a constant expression initializer, it is a compile-time constant.
#+begin_src cpp :main no
#include <iostream>

int getNumber()
{
    std::cout << "Enter a number: ";
    int y{};
    std::cin >> y;

    return y;
}

int main()
{
    // Non-const variables are always non-constants:
    int a { 5 };                 // 5 is a constant expression
    double b { 1.2 + 3.4 };      // 1.2 + 3.4 is a constant expression

    // Const integral variables with a constant expression initializer are compile-time constants:
    const int c { 5 };           // 5 is a constant expression
    const int d { c };           // c is a constant expression
    const long e { c + 2 };      // c + 2 is a constant expression

    // Other const variables are runtime constants:
    const int f { a };           // a is not a constant expression
    const int g { a + 1 };       // a + 1 is not a constant expression
    const int h { a + c };       // a + c is not a constant expression
    const int i { getNumber() }; // getNumber() is not a constant expression

    const double j { b };        // b is not a constant expression
    const double k { 1.2 };      // 1.2 is a constant expression

    return 0;
}
#+end_src

*** pros and cons
good for performance, but bad for debug.

** Constexpr variable
Any constant variable whose initializer is a constant expression should be declared as constexpr.

Any constant variable whose initializer is not a constant expression (making it a runtime constant) should be declared as const.
#+begin_src cpp
#include <iostream>

// The return value of a non-constexpr function is not a constant expression
int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
#+end_src

| Term                  | Definition                                                                                                                                                        |
|-----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Compile-time constant | A value or non-modifiable object whose value must be known at compile time (e.g. literals and constexpr variables).                                               |
| Constexpr             | Keyword that declares variables as compile-time constants (and functions that can be evaluated at compile-time). Informally, shorthand for “constant expression”. |
| Constant expression   | An expression that contains only compile-time constants and operators/functions that support compile-time evaluation.                                             |
| Runtime expression    | An expression that is not a constant expression.                                                                                                                  |
| Runtime constant      | A value or non-modifiable object that is not a compile-time constant.                                                                                             |

** Ternary Operator
Parenthesize the entire conditional operation (including operands) when used in a compound expression.

For readability, consider parenthesizing the condition if it contains any operators (other than the function call operator).

*** Warning
The type of the second and third operand must match.
The compiler must be able to find a way to convert one or both of the second and third operands to matching types. The conversion rules the compiler uses are fairly complex and may yield surprising results in some cases.
#+begin_src cpp
std::cout << (true ? 1 : 2) << '\n';    // okay: both operands have matching type int

std::cout << (false ? 1 : 2.2) << '\n'; // okay: int value 1 converted to double

std::cout << (true ? -1 : 2u) << '\n';  // surprising result: -1 converted to unsigned int, result out of range
#+end_src

*** When should you use the conditional operator?
- Initializing an object with one of two values.
- Assigning one of two values to an object.
- Passing one of two values to a function.
- Returning one of two values from a function.
- Printing one of two values.

Prefer to avoid the conditional operator in complicated expressions.

** Inline function and variable
Avoid the use of the inline keyword unless you have a specific, compelling reason to do so (e.g. you’re defining those functions or variables in a header file).

*** The following are implicitly inline:

Functions defined inside a class, struct, or union type definition 
Constexpr / consteval functions.
Functions implicitly instantiated from function templates.

** Constexpr function
When a constexpr function evaluates at runtime, it evaluates just like a normal (non-constexpr) function would. In other words, the constexpr has no effect in this case.

All constexpr functions should be evaluatable at compile-time, as they will be required to do so in contexts that require a constant expression.

Always test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.

*** definition
Constexpr/consteval functions used in a single source file (.cpp) can be defined in the source file above where they are used.

Constexpr/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.

*** Recap
Marking a function as constexpr means it can be used in a constant expression. It does not mean “will evaluate at compile-time”.

A constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.

In contexts that do not require a constant expression, the compiler may choose whether to evaluate a constant expression (which may contain constexpr function calls) at compile-time or at runtime.

A runtime (non-constant) expression (which may contain constexpr function calls or non-constexpr function calls) will evaluate at runtime.

Unless you have a specific reason not to, a function that can evaluate as part of a constant expression should be made constexpr.

A function that cannot be evaluated as part of a constant expression should not be marked as constexpr.

*** Consteval
Use consteval if you have a function that must evaluate at compile-time for some reason (e.g. because it does something that can only be done at compile time).

Using consteval to make constexpr execute at compile-time.
#+begin_src cpp :main no
#include <iostream>

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x > y ? x : y);
}

int main()
{
    std::cout << greater(5, 6) << '\n';                  // may or may not execute at compile-time
    std::cout << compileTimeEval(greater(5, 6)) << '\n'; // will execute at compile-time

    int x { 5 };
    std::cout << greater(x, 6) << '\n';                  // we can still call the constexpr version at runtime if we wish

    return 0;
}
#+end_src


** String
If using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace. This needs to be done for each std::getline() call, as std::ws is not preserved across calls.

When extracting to a variable, the extraction operator (>>) ignores leading whitespace. It stops extracting when encountering non-leading whitespace.

std::getline() does not ignore leading whitespace. If you want it to ignore leading whitespace, pass std::cin >> std::ws as the first argument. It stops extracting when encountering a newline.
#+begin_src cpp
std::cout << "Enter your full name: ";
std::string name{};
std::getline(std::cin >> std::ws, name); // read a full line of text into name

std::cout << "Enter your favorite color: ";
std::string color{};
std::getline(std::cin >> std::ws, color); // read a full line of text into color

std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';
#+end_src

*** Length
Beware size type.
#+begin_src cpp
std::string name{ "Alex" };
std::cout << name << " has " << name.length() << " characters\n";
std::cout << name << " has " << std::ssize(name) << " characters\n";
int len { static_cast<int>(std::ssize(name)) };
#+end_src

*** Expensive string
Do not pass std::string by value, as it makes an expensive copy.

However, as a rule of thumb, it is okay to return a std::string by value when the expression of the return statement resolves to any of the following:

- A local variable of type std::string.
- A std::string that has been returned by value from another function call or operator.
- A std::string temporary that is created as part of the return statement.


*** Literal string
#+begin_src cpp :includes '(<string> <iostream>)
using namespace std::string_literals; // easy access to the s suffix

std::cout << "foo\n";   // no suffix is a C-style string literal
std::cout << "goo\n"s;  // s suffix is a std::string literal
#+end_src

"Hello"s resolves to std::string { "Hello", 5 } which creates a temporary std::string initialized with C-style string literal “Hello” (which has a length of 5, excluding the implicit null-terminator).

** String_view

Unlike std::string, std::string_view has full support for constexpr:

Prefer std::string_view over std::string when you need a read-only string, especially for function parameters.
*** Convert to String
#+begin_src cpp :main no
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str)
{
	std::cout << str << '\n';
}

int main()
{
	std::string_view sv{ "Hello, world!" };

	// printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string

	std::string s{ sv }; // okay: we can create std::string using std::string_view initializer
	printString(s);      // and call the function with the std::string

	printString(static_cast<std::string>(sv)); // okay: we can explicitly cast a std::string_view to a std::string

	return 0;
}
#+end_src
*** Literals string_view
#+begin_src cpp :main no
#include <iostream>
#include <string>      // for std::string
#include <string_view> // for std::string_view

int main()
{
    using namespace std::string_literals;      // access the s suffix
    using namespace std::string_view_literals; // access the sv suffix

    std::cout << "foo\n";   // no suffix is a C-style string literal
    std::cout << "goo\n"s;  // s suffix is a std::string literal
    std::cout << "moo\n"sv; // sv suffix is a std::string_view literal

    return 0;
}
#+end_src

** view
A view is dependent on the object being viewed. If the object being viewed is modified or destroyed while the view is still being used, unexpected or undefined behavior will result.
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string_view sv{};

{ // create a nested block
    std::string s{ "Hello, world!" }; // create a std::string local to this nested block
    sv = s; // sv is now viewing s
} // s is destroyed here, so sv is now viewing an invalid string

std::cout << sv << '\n'; // undefined behavior
#+end_src

Do not initialize a std::string_view with a std::string literal, as this will leave the std::string_view dangling.

It is okay to initialize a std::string_view with a C-style string literal or a std::string_view literal. It’s also okay to initialize a std::string_view with a C-style string object, a std::string object, or a std::string_view object, as long as that string object outlives the view.
#+begin_src cpp
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior
#+end_src

** Revalidate string_view
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior

sv = s;                    // revalidate sv: sv is now viewing s again
std::cout << sv << '\n';   // prints "Hello, universe!"
#+end_src

* Next
https://www.learncpp.com/cpp-tutorial/stdstring_view-part-2/
