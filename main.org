#+PROPERTY: header-args:cpp :results output :includes <iostream> :flags -ggdb -pedantic-errors -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion -Wshadow -Werror -std=c++2b

* Basic
** Initialization
https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/

Prefer list or value initialization.

#+begin_src cpp
int a;         // no initializer                            (default initialization)
int b = 5;     // initial value after equals sign           (copy initialization)
int c( 6 );    // initial value in parenthesis              (direct initialization)

// List initialization methods                              (C++11) (preferred)
int d { 7 };   // initial value in braces                   (direct list initialization)
int e = { 8 }; // initial value in braces after equals sign (copy list initialization)
int f {};      // initializer is empty braces               (value initialization)
#+end_src

*** multiple init
#+begin_src cpp
int a = 5, b = 6;          // copy initialization
int c( 7 ), d( 8 );        // direct initialization
int e { 9 }, f { 10 };     // direct brace initialization
int g = { 9 }, h = { 10 }; // copy brace initialization
int i {}, j {};            // value initialization
#+end_src

use [[maybe_unused]​] attribute to avoid error, via abbrev.

** iostream
Prefer \n over std::endl when outputting text to the console.


* Function and File
** Return value
If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.
#+begin_src cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
#+end_src

** Comment unused function parameter
When a function parameter exists but is not used in the body of the function, do not give it a name. You can optionally put a name inside a comment.
#+begin_src cpp
void doSomething(int /*count*/)
{
}
#+end_src

** Define variable
Define your local variables as close to their first use as reasonable.

** Preprocessor
The entire process of preprocessing, compiling, and linking is called translation.

Preprocessor doesn’t understand C++ concepts.

Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one file do not have any impact on other files (unless they are #included into another file).


** Header
Source files should #include their paired header file (if one exists).

Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.

Use the standard library header files without the .h extension. User-defined headers should still use a .h extension.

Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

*** #include order
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

That way, if one of your user-defined headers is missing an #include for a 3rd party library or standard library header, it’s more likely to cause a compile error so you can fix it.

** Header Guard
Beware two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\config.h and directoryB\config.h).

** Design and Implementation

*** Design step
**** Define goal
It is often useful to express this as a user-facing outcome. For example:

1. Allow the user to organize a list of names and associated phone numbers.
2. Generate randomized dungeons that will produce interesting looking caverns.
3. Generate a list of stock recommendations for stocks that have high dividends.
4. Model how long it takes for a ball dropped off a tower to hit the ground.
**** Define requirements
Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc…), as well as the capabilities that the program must exhibit in order to meet the users’ needs. Note that your requirements should similarly be focused on the “what”, not the “how”. For example:

- Phone numbers should be saved, so they can be recalled later.
- The randomized dungeon should always contain a way to get from the entrance to an exit.
- The stock recommendations should leverage historical pricing data.
- The user should be able to enter the height of the tower.
- We need a testable version within 7 days.
- The program should produce results within 10 seconds of the user submitting their request.
- The program should crash in less than 0.1% of user sessions.
**** Define your tools, targets, and backup plan
- Defining what target architecture and/or OS your program will run on.
- Determining what set of tools you will be using.
- Determining whether you will write your program alone or as part of a team.
- Defining your testing/feedback/release strategy.
- Determining how you will back up your code.
**** Break hard problems down into easy problems
The top level task becomes main() (because it is the main problem you are trying to solve). The subitems become functions in the program.
**** Figure out the sequence of events
If we were writing a calculator, we might do things in this order:

1. Get first number from user
2. Get mathematical operation from user
3. Get second number from user
4. Calculate result
5. Print result

At this point, we’re ready for implementation.

*** Implementation
**** Outlining your main function
#+begin_src cpp
int main()
{
    // Get first number from user
//    getUserInput();

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Implement each function
1. Define the function prototype (inputs and outputs)
2. Write the function
3. Test the function
#+begin_src cpp
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Final testing
Once your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.

*** Words of advice when writing programs

**** Keep your programs simple to start
Often new programmers have a grand vision for all the things they want their program to do. “I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon”. If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress. Instead, make your first goal as simple as possible, something that is definitely within your reach. For example, “I want to be able to display a 2-dimensional field on the screen”.



**** Add features over time
Once you have your simple program working and working well, then you can add features to it. For example, once you can display your field, add a character who can walk around. Once you can walk around, add walls that can impede your progress. Once you have walls, build a simple town out of them. Once you have a town, add merchants. By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.

**** Focus on one area at a time
New programmers will often write the entire program in one pass. Then when they compile it for the first time, the compiler reports hundreds of errors. This can not only be intimidating, if your code doesn’t work, it may be hard to figure out why. Instead, write a piece of code, and then compile and test it immediately. If it doesn’t work, you’ll know exactly where the problem is, and it will be easy to fix. Once you are sure that the code works, move to the next piece and repeat. It may take longer to finish writing your code, but when you are done the whole thing should work, and you won’t have to spend twice as long trying to figure out why it doesn’t.

**** Don’t invest in perfecting early code
The first draft of a feature (or program) is rarely good. Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things. If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary. Instead, get your features minimally working and then move on. As you gain confidence in your solutions, apply successive layers of polish. Don’t aim for perfect -- non-trivial programs are never perfect, and there’s always something more that could be done to improve them. Get to “good enough” and move on.



**** Optimize for maintainability, not performance
There is a famous quote (by Donald Knuth) that says “premature optimization is the root of all evil”. New programmers often spend far too much time thinking about how to micro-optimize their code (e.g. trying to figure out which of 2 statements is faster). This rarely matters. Most performance benefits come from good program structure, using the right tools and capabilities for the problem at hand, and following best practices. Additional time should be used to improve the maintainability of your code. Find redundancy and remove it. Split up long functions into shorter ones. Replace awkward or hard to use code with something better. The end result will be code that is easier to improve and optimize later (after you’ve determined where optimization is actually needed) and fewer bugs.



* Debug
** Step
1. Find the root cause of the problem (usually the line of code that’s not working).
2. Ensure you understand why the issue is occurring.
3. Determine how you’ll fix the issue.
4. Repair the issue causing the problem.
5. Retest to ensure the problem has been fixed.
6. Retest to ensure no new problems have emerged.

** Tactic

*** std::cerr instead of std::cout when debugging
cerr is unbufferd.

*** Debug with preprocessor
#+begin_src cpp
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging, or define in header file

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
#+end_src

*** Logger
Such as spdlog or plog.

** Refactor
Ideally, a function should be less than ten lines. Functions that are less than five lines are even better.

Remember that the goal here is to maximize comprehension and maintainability, not to minimize function length -- abandoning best practices or using obscure coding techniques to save a line or two doesn’t do your code any favors.

** Defensive programming
Defensive programming is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code. These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).

** unit testing
#+begin_src cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void testadd()
{
	std::cout << "This function should print: 2 0 0 -2\n";
	std::cout << add(1, 1) << ' ';
	std::cout << add(-1, 1) << ' ';
	std::cout << add(1, -1) << ' ';
	std::cout << add(-1, -1) << ' ';
}

int main()
{
	testadd();

	return 0;
}
#+end_src

* Fundamental Data Type
** Int
#+begin_src cpp
short s;      // prefer "short" instead of "short int"
int i;
long l;       // prefer "long" instead of "long int"
long long ll; // prefer "long long" instead of "long long int"
signed short ss;
signed int si;
signed long sl;
signed long long sll;
#+end_src
Prefer the shorthand types that do not use the int suffix or signed prefix.

*** Signed integer range
$-(2^(n-1))$ to $2^(n-1)-1$

If outside the range, then overflow.

*** Unsigned integer
Avoid unsigned integer.

Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.

**** when should you use unsigned numbers?
First, unsigned numbers are preferred when dealing with bit manipulation (covered in chapter O -- that’s a capital ‘o’, not a ‘0’). They are also useful when well-defined wrap-around behavior is required (useful in some algorithms like encryption and random number generation).

Second, use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing. We’ll talk more about this in the lessons on arrays and array indexing.

Also note that if you’re developing for an embedded system (e.g. an Arduino) or some other processor/memory limited context, use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.

*** fixed-width-integers and size_t

**** integer choice

***** Prefer

Prefer int when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer) and the variable is short-lived (e.g. destroyed at the end of the function). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
Prefer std::int#_t when storing a quantity that needs a guaranteed range.
Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required.

***** Avoid

short and long integers -- use a fixed-width type instead.
Unsigned types for holding quantities.
The 8-bit fixed-width integer types.
The fast and least fixed-width types.
Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…

**** size_t
std::size_t is an alias for an implementation-defined unsigned integral type. It is used within the standard library to represent the byte-size or length of objects.

If you use std::size_t explicitly in your code, #include one of the headers that defines std::size_t (we recommend <cstddef>).
Using sizeof does not require a header (even though it return a value whose type is std::size_t).
** Float
Prefer: double > float > long float

#+begin_src cpp
int a { 5 };      // 5 means integer
double b { 5.0 }; // 5.0 is a floating point literal (no suffix means double type by default)
float c { 5.0f }; // 5.0 is a floating point literal, f suffix means float type

int d { 0 }       // 0 is an integer
double e { 0.0 }  // 0.0 is a double
#+end_src
Note that by default, floating point literals default to type double. An f suffix is used to denote a literal of type float.

Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.

*** Maybe auto scientific notation
#+begin_src cpp
std::cout << 9.87654321f << '\n';
std::cout << 987.654321f << '\n';
std::cout << 987654.321f << '\n';
std::cout << 9876543.21f << '\n';
std::cout << 0.0000987654321f << '\n';
#+end_src

*** default double if not suffix with 'f'
#+begin_src cpp :includes '(<iostream> <iomanip>)
std::cout << std::setprecision(17); // show 17 digits of precision
std::cout << 3.33333333333333333333333333333333333333f <<'\n'; // f suffix means float
std::cout << 3.33333333333333333333333333333333333333 << '\n'; // no suffix means double
#+end_src

*** Precision issues don’t just impact fractional numbers
#+begin_src cpp :includes '(<iostream> <iomanip>)
float f { 123456789.0f }; // f has 10 significant digits
std::cout << std::setprecision(9); // to show 9 digits in f
std::cout << f << '\n';
#+end_src

*** Be wary of using floating point numbers for financial or currency data.
#+begin_src cpp :includes '(<iostream> <iomanip>)
std::cout << std::setprecision(17);

double d1{ 1.0 };
std::cout << d1 << '\n';

double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0
std::cout << d2 << '\n';
#+end_src

*** NaN and Inf
Avoid division by 0.0 altogether, even if your compiler supports it.
#+begin_src cpp
double zero {0.0};
double posinf { 5.0 / zero }; // positive infinity
std::cout << posinf << '\n';

double neginf { -5.0 / zero }; // negative infinity
std::cout << neginf << '\n';

double nan { zero / zero }; // not a number (mathematically invalid)
std::cout << nan << '\n';
#+end_src

** Boolean
#+begin_src cpp
bool b1 { true };
bool b2 { false };
b1 = false;
bool b3 {}; // default initialize to false
bool b1 { !true }; // b1 will be initialized with the value false
bool b2 { !false }; // b2 will be initialized with the value true
#+end_src

*** Stored as integer
#+begin_src cpp
std::cout << true << '\n'; // true evaluates to 1
std::cout << !true << '\n'; // !true evaluates to 0

bool b {false};
std::cout << b << '\n'; // b is false, which evaluates to 0
std::cout << !b << '\n'; // !b is true, which evaluates to 1
#+end_src

*** Boolalpha
#+begin_src cpp
std::cout << true << '\n';
std::cout << false << '\n';

std::cout << std::boolalpha; // print bools as true or false
// std::cout << std::noboolalpha; // turn it back

std::cout << true << '\n';
std::cout << false << '\n';
#+end_src

*** Integer to Boolean conversion
#+begin_src cpp
bool bFalse { 0 }; // okay: initialized to false
bool bTrue  { 1 }; // okay: initialized to true
bool bNo    { 2 }; // error: narrowing conversions disallowed

std::cout << bFalse << bTrue << bNo << '\n';
#+end_src

but copy init works.
#+begin_src cpp
std::cout << std::boolalpha; // print bools as true or false

bool b1 = 4 ; // copy initialization allows implicit conversion from int to bool
std::cout << b1 << '\n';

bool b2 = 0 ; // copy initialization allows implicit conversion from int to bool
std::cout << b2 << '\n';
#+end_src

*** Inputting Boolean values
#+begin_src cpp :eval no
bool b{}; // default initialize to false
std::cout << "Enter a boolean value: ";
std::cin >> b;
std::cout << "You entered: " << b << '\n';
#+end_src

Only accept 0 or 1; if not enable 'std::boolalpha'.
Enabling std::boolalpha for input will only allow lower-cased false or true to be accepted. Variations with capital letters will not be accepted. 0 and 1 will also no longer be accepted.
#+begin_src cpp :eval no
bool b{};
std::cout << "Enter a boolean value: ";

// Allow the user to input 'true' or 'false' for boolean values
// This is case-sensitive, so True or TRUE will not work
std::cin >> std::boolalpha;
std::cin >> b;

// Let's also output bool values as `true` or `false`
std::cout << std::boolalpha;
std::cout << "You entered: " << b << '\n';
#+end_src

*** Return value
retrun true or false.
#+begin_src cpp :eval no :main no
// returns true if x and y are equal, false otherwise
bool isEqual(int x, int y)
{
    return x == y; // operator== returns true if x equals y, and false otherwise
}

int main()
{
    std::cout << "Enter an integer: ";
    int x{};
    std::cin >> x;

    std::cout << "Enter another integer: ";
    int y{};
    std::cin >> y;

    std::cout << std::boolalpha; // print bools as true or false

    std::cout << x << " and " << y << " are equal? ";
    std::cout << isEqual(x, y) << '\n'; // will return true or false
** Char
Avoid militarist literals (e.g. '56').
*** Other char type
wchar_t should be avoided in almost all cases (except when interfacing with the Windows API).

You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible.
*** Type Conversion and static_cast
Type conversion uses direct initialization to produce a new value of the target type from a value of a different type.

Prefer static_cast<type>(x)
* Constant and String
** Constant variable
Place const before the type (because it is more conventional to do so).
Don’t use const when passing by value.
Don’t use const when returning by value.
Prefer constant variables over object-like macros with substitution text.
** Literal
*** Type of literal
| Literal value        | Examples        | Default literal type | Note                                      |
|----------------------+-----------------+----------------------+-------------------------------------------|
| integer value        | 5, 0, -3        | int                  |                                           |
| boolean value        | true, false     | bool                 |                                           |
| floating point value | 1.2, 0.0, 3.4   | double (not float!)  |                                           |
| character            | ‘a’, ‘\n’       | char                 |                                           |
| C-style string       | “Hello, world!” | const char[14]       | see C-style string literals section below |
*** Literal suffixes
If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix. Here are some of the more common suffixes:
In most cases, suffixes aren’t needed (except for f).
| Data type      | Suffix                                 | Meaning                                   |
|----------------+----------------------------------------+-------------------------------------------|
| integral       | u or U                                 | unsigned int                              |
| integral       | l or L                                 | long                                      |
| integral       | ul, uL, Ul, UL, lu, lU, Lu, LU         | unsigned long                             |
| integral       | ll or LL                               | long long                                 |
| integral       | ull, uLL, Ull, ULL, llu, llU, LLu, LLU | unsigned long long                        |
| integral       | z or Z                                 | The signed version of std::size_t (C++23) |
| integral       | uz, uZ, Uz, UZ, zu, zU, Zu, ZU         | std::size_t (C++23)                       |
| floating point | f or F                                 | float                                     |
| floating point | l or L                                 | long double                               |
| string         | s                                      | std::string                               |
| string         | sv                                     | std::string_view                          |
Because lower-case L can look like numeric 1 in some fonts, some developers prefer to use upper-case literals. Others use lower case suffixes except for L.
*** String
C-style string literals are const objects that are created at the start of the program and are guaranteed to exist for the entirety of the program.
Unlike C-style string literals, std::string and std::string_view literals create temporary objects. These temporary objects must be used immediately, as they are destroyed at the end of the full expression in which they are created.
*** Magic number
A magic number is a literal (usually a number) that either has an unclear meaning or may need to be changed later.
Avoid magic numbers in your code (use constexpr variables instead).
** Number
| decimal | octal | hexdecimal | binary |
|---------+-------+------------+--------|
|       1 |    01 |        0x1 | 0b1    |
|      12 |   014 |        0xC | 0b1100 |

*** Seperator
#+begin_src cpp
int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
long value { 2'132'673'462 }; // much easier to read than 2132673462
int cin { 0b'1011'0010 };  // error: ' used before first digit of value
#+end_src

*** Output
#+begin_src cpp
int x { 12 };
std::cout << x << '\n'; // decimal (by default)
std::cout << std::hex << x << '\n'; // hexadecimal
std::cout << x << '\n'; // now hexadecimal
std::cout << std::oct << x << '\n'; // octal
std::cout << std::dec << x << '\n'; // return to decimal
std::cout << x << '\n'; // decimal
#+end_src
Note that once applied, the I/O manipulator remains set for future output until it is changed again.

binary
#+begin_src cpp :main no
#include <bitset> // for std::bitset
#include <iostream>

int main()
{
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it

	return 0;
}
#+end_src

**** Format and Print
#+begin_src cpp :main no
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} formats the argument as binary digits
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} formats the argument as 0b-prefixed binary digits

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, format/print two arguments (same as above) and a newline

    return 0;
}
#+end_src


** Constant expressions
The most common type of operators and functions that support compile-time evaluation include:

Arithmetic operators with operands that are compile-time constants (e.g. 1 + 2)
Constexpr and consteval functions (we’ll discuss these later in the chapter)

If the const variable has an integral type and a constant expression initializer, it is a compile-time constant.
#+begin_src cpp :main no
#include <iostream>

int getNumber()
{
    std::cout << "Enter a number: ";
    int y{};
    std::cin >> y;

    return y;
}

int main()
{
    // Non-const variables are always non-constants:
    int a { 5 };                 // 5 is a constant expression
    double b { 1.2 + 3.4 };      // 1.2 + 3.4 is a constant expression

    // Const integral variables with a constant expression initializer are compile-time constants:
    const int c { 5 };           // 5 is a constant expression
    const int d { c };           // c is a constant expression
    const long e { c + 2 };      // c + 2 is a constant expression

    // Other const variables are runtime constants:
    const int f { a };           // a is not a constant expression
    const int g { a + 1 };       // a + 1 is not a constant expression
    const int h { a + c };       // a + c is not a constant expression
    const int i { getNumber() }; // getNumber() is not a constant expression

    const double j { b };        // b is not a constant expression
    const double k { 1.2 };      // 1.2 is a constant expression

    return 0;
}
#+end_src

*** pros and cons
good for performance, but bad for debug.

** Constexpr variable
Any constant variable whose initializer is a constant expression should be declared as constexpr.

Any constant variable whose initializer is not a constant expression (making it a runtime constant) should be declared as const.
#+begin_src cpp
#include <iostream>

// The return value of a non-constexpr function is not a constant expression
int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
#+end_src

| Term                  | Definition                                                                                                                                                        |
|-----------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Compile-time constant | A value or non-modifiable object whose value must be known at compile time (e.g. literals and constexpr variables).                                               |
| Constexpr             | Keyword that declares variables as compile-time constants (and functions that can be evaluated at compile-time). Informally, shorthand for “constant expression”. |
| Constant expression   | An expression that contains only compile-time constants and operators/functions that support compile-time evaluation.                                             |
| Runtime expression    | An expression that is not a constant expression.                                                                                                                  |
| Runtime constant      | A value or non-modifiable object that is not a compile-time constant.                                                                                             |

** Ternary Operator
Parenthesize the entire conditional operation (including operands) when used in a compound expression.

For readability, consider parenthesizing the condition if it contains any operators (other than the function call operator).

*** Warning
The type of the second and third operand must match.
The compiler must be able to find a way to convert one or both of the second and third operands to matching types. The conversion rules the compiler uses are fairly complex and may yield surprising results in some cases.
#+begin_src cpp
std::cout << (true ? 1 : 2) << '\n';    // okay: both operands have matching type int

std::cout << (false ? 1 : 2.2) << '\n'; // okay: int value 1 converted to double

std::cout << (true ? -1 : 2u) << '\n';  // surprising result: -1 converted to unsigned int, result out of range
#+end_src

*** When should you use the conditional operator?
- Initializing an object with one of two values.
- Assigning one of two values to an object.
- Passing one of two values to a function.
- Returning one of two values from a function.
- Printing one of two values.

Prefer to avoid the conditional operator in complicated expressions.

** Inline function and variable
Avoid the use of the inline keyword unless you have a specific, compelling reason to do so (e.g. you’re defining those functions or variables in a header file).

*** The following are implicitly inline:

Functions defined inside a class, struct, or union type definition 
Constexpr / consteval functions.
Functions implicitly instantiated from function templates.

** Constexpr function
When a constexpr function evaluates at runtime, it evaluates just like a normal (non-constexpr) function would. In other words, the constexpr has no effect in this case.

All constexpr functions should be evaluatable at compile-time, as they will be required to do so in contexts that require a constant expression.

Always test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.

*** definition
Constexpr/consteval functions used in a single source file (.cpp) can be defined in the source file above where they are used.

Constexpr/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.

*** Recap
Marking a function as constexpr means it can be used in a constant expression. It does not mean “will evaluate at compile-time”.

A constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.

In contexts that do not require a constant expression, the compiler may choose whether to evaluate a constant expression (which may contain constexpr function calls) at compile-time or at runtime.

A runtime (non-constant) expression (which may contain constexpr function calls or non-constexpr function calls) will evaluate at runtime.

Unless you have a specific reason not to, a function that can evaluate as part of a constant expression should be made constexpr.

A function that cannot be evaluated as part of a constant expression should not be marked as constexpr.

*** Consteval
Use consteval if you have a function that must evaluate at compile-time for some reason (e.g. because it does something that can only be done at compile time).

Using consteval to make constexpr execute at compile-time.
#+begin_src cpp :main no
#include <iostream>

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x > y ? x : y);
}

int main()
{
    std::cout << greater(5, 6) << '\n';                  // may or may not execute at compile-time
    std::cout << compileTimeEval(greater(5, 6)) << '\n'; // will execute at compile-time

    int x { 5 };
    std::cout << greater(x, 6) << '\n';                  // we can still call the constexpr version at runtime if we wish

    return 0;
}
#+end_src


** String
If using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace. This needs to be done for each std::getline() call, as std::ws is not preserved across calls.

When extracting to a variable, the extraction operator (>>) ignores leading whitespace. It stops extracting when encountering non-leading whitespace.

std::getline() does not ignore leading whitespace. If you want it to ignore leading whitespace, pass std::cin >> std::ws as the first argument. It stops extracting when encountering a newline.
#+begin_src cpp
std::cout << "Enter your full name: ";
std::string name{};
std::getline(std::cin >> std::ws, name); // read a full line of text into name

std::cout << "Enter your favorite color: ";
std::string color{};
std::getline(std::cin >> std::ws, color); // read a full line of text into color

std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';
#+end_src

*** Length
Beware size type.
#+begin_src cpp
std::string name{ "Alex" };
std::cout << name << " has " << name.length() << " characters\n";
std::cout << name << " has " << std::ssize(name) << " characters\n";
int len { static_cast<int>(std::ssize(name)) };
#+end_src

*** Expensive string
Do not pass std::string by value, as it makes an expensive copy.

However, as a rule of thumb, it is okay to return a std::string by value when the expression of the return statement resolves to any of the following:

- A local variable of type std::string.
- A std::string that has been returned by value from another function call or operator.
- A std::string temporary that is created as part of the return statement.


*** Literal string
#+begin_src cpp :includes '(<string> <iostream>)
using namespace std::string_literals; // easy access to the s suffix

std::cout << "foo\n";   // no suffix is a C-style string literal
std::cout << "goo\n"s;  // s suffix is a std::string literal
#+end_src

"Hello"s resolves to std::string { "Hello", 5 } which creates a temporary std::string initialized with C-style string literal “Hello” (which has a length of 5, excluding the implicit null-terminator).

** String_view

Unlike std::string, std::string_view has full support for constexpr:

Prefer std::string_view over std::string when you need a read-only string, especially for function parameters.
*** Convert to String
#+begin_src cpp :main no
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str)
{
	std::cout << str << '\n';
}

int main()
{
	std::string_view sv{ "Hello, world!" };

	// printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string

	std::string s{ sv }; // okay: we can create std::string using std::string_view initializer
	printString(s);      // and call the function with the std::string

	printString(static_cast<std::string>(sv)); // okay: we can explicitly cast a std::string_view to a std::string

	return 0;
}
#+end_src
*** Literals string_view
#+begin_src cpp :main no
#include <iostream>
#include <string>      // for std::string
#include <string_view> // for std::string_view

int main()
{
    using namespace std::string_literals;      // access the s suffix
    using namespace std::string_view_literals; // access the sv suffix

    std::cout << "foo\n";   // no suffix is a C-style string literal
    std::cout << "goo\n"s;  // s suffix is a std::string literal
    std::cout << "moo\n"sv; // sv suffix is a std::string_view literal

    return 0;
}
#+end_src

** view
A view is dependent on the object being viewed. If the object being viewed is modified or destroyed while the view is still being used, unexpected or undefined behavior will result.
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string_view sv{};

{ // create a nested block
    std::string s{ "Hello, world!" }; // create a std::string local to this nested block
    sv = s; // sv is now viewing s
} // s is destroyed here, so sv is now viewing an invalid string

std::cout << sv << '\n'; // undefined behavior
#+end_src

Do not initialize a std::string_view with a std::string literal, as this will leave the std::string_view dangling.

It is okay to initialize a std::string_view with a C-style string literal or a std::string_view literal. It’s also okay to initialize a std::string_view with a C-style string object, a std::string object, or a std::string_view object, as long as that string object outlives the view.
#+begin_src cpp
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior
#+end_src

** Revalidate string_view
#+begin_src cpp :includes '(<string> <string_view> <iostream>)
std::string s { "Hello, world!" };
std::string_view sv { s }; // sv is now viewing s

s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
std::cout << sv << '\n';   // undefined behavior

sv = s;                    // revalidate sv: sv is now viewing s again
std::cout << sv << '\n';   // prints "Hello, universe!"
#+end_src

** returning std::string_view
If an argument is a temporary that is destroyed at the end of the full expression containing the function call, the returned std::string_view must be used immediately, as it will be left dangling after the temporary is destroyed.

** view modification function
The remove_prefix() member function removes characters from the left side of the view.
The remove_suffix() member function removes characters from the right side of the view.
#+begin_src cpp
#include <iostream>
#include <string_view>

int main()
{
	std::string_view str{ "Peach" };
	std::cout << str << '\n';

	// Remove 1 character from the left side of the view
	str.remove_prefix(1);
	std::cout << str << '\n';

	// Remove 2 characters from the right side of the view
	str.remove_suffix(2);
	std::cout << str << '\n';

	str = "Peach"; // reset the view
	std::cout << str << '\n';

	return 0;
}
#+end_src

** null-terminate
A C-style string literal and a std::string are always null-terminated.
A std::string_view may or may not be null-terminated.

Take care not to write any code that assumes a std::string_view is null terminated.
If you have a non-null-terminated std::string_view and you need a null-terminated string for some reason, convert the std::string_view into a std::string.

** When to use std::string vs std::string_view

*** Variables
**** Use a std::string variable when:

You need a string that you can modify.
You need to store user-inputted text.
You need to store the return value of a function that returns a std::string.

**** Use a std::string_view variable when:

You need read-only access to part or all of a string that already exists elsewhere and will not be modified or destroyed before use of the std::string_view is complete.
You need a symbolic constant for a C-style string.
You need to continue viewing the return value of a function that returns a C-style string or a non-dangling std::string_view.

*** Function parameters
**** Use a std::string function parameter when:

The function needs to modify the string passed in as an argument without affecting the caller. This is rare.
You are using language standard C++14 or older and aren’t comfortable using references yet.

**** Use a std::string_view function parameter when:

The function needs a read-only string.
The function needs to work with non-null-terminated strings.

*** Return types
**** Use a std::string return type when:

The return value is a std::string local variable or function parameter.
The return value is a function call or operator that returns a std::string by value.

**** Use a std::string_view return type when:

The function returns a C-style string literal or local std::string_view that has been initialized with a C-style string literal.
The function returns a std::string_view parameter.

** Some important about std::string and std::string_view
*** std::string
- Initializing and copying std::string is expensive, so avoid this as much as possible.
- Avoid passing std::string by value, as this makes a copy.
- If possible, avoid creating short-lived std::string objects.
- Modifying a std::string will invalidate any views to that string.
- It is okay to return a local std::string by value.
*** std::string_view
- std::string_view is typically used for passing string function parameters and returning string literals.
- Because C-style string literals exist for the entire program, it is always okay to set a std::string_view to a C-style string literal.
- When a string is destroyed, all views to that string are invalidated.
- Using an invalidated view (other than using assignment to revalidate the view) will cause undefined behavior.
- A std::string_view may or may not be null-terminated.
* Operators
** Operator precedence and associativity
Ensure that the expressions (or function calls) you write are not dependent on operand (or argument) evaluation order.
** Remainder and exponentiatio
Prefer to compare the result of the remainder operator (operator%) against 0 if possible.
** Increment/decrement operators, and side effects
Favor the prefix versions, as they are more performant and less likely to cause surprises.

Don’t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined.

One exception is for simple assignment expressions such as x = x + y (which is essentially equivalent to x += y).
** The comma operator
#+begin_src cpp
z = (a, b); // evaluate (a, b) first to get result of b, then assign that value to variable z.
z = a, b; // evaluates as "(z = a), b", so z gets assigned the value of a, and b is evaluated and discarded.
#+end_src
Avoid using the comma operator, except within for loops.
** Relational operators and floating point comparisons
Don’t add unnecessary == or != to boolean conditions. It makes them harder to read without offering any additional value.

*** Float
Comparing floating point values using any of the relational operators can be dangerous. This is because floating point values are not precise, and small rounding errors in the floating point operands may cause them to be slightly smaller or slightly larger than expected. And this can throw off the relational operators.

Avoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated.
It is safe to compare a floating point literal with a variable of the same type that has been initialized with a literal of the same type, so long as the number of significant digits in each literal does not exceed the minimum precision for that type. Float has a minimum precision of 6 significant digits, and double has a minimum precision of 15 significant digits.

It is generally not safe to compare floating point literals of different types.

**** approximatelyEqual
#+begin_src cpp :main no
// C++23 version
#include <algorithm> // for std::max
#include <cmath>     // for std::abs (constexpr in C++23)

// Return true if the difference between a and b is within epsilon percent of the larger of a and b
constexpr bool approximatelyEqualRel(double a, double b, double relEpsilon)
{
	return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

// Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b
constexpr bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)
{
    // Check if the numbers are really close -- needed when comparing numbers near zero.
    if (std::abs(a - b) <= absEpsilon)
        return true;

    // Otherwise fall back to Knuth's algorithm
    return approximatelyEqualRel(a, b, relEpsilon);
}
#+end_src

** Logical operators
*** De Morgan’s laws
!(x && y) is equivalent to !x || !y
!(x || y) is equivalent to !x && !y

*** XOR
#+begin_src cpp
if (a != b) ... // a XOR b, assuming a and b are bool
if (a != b != c) ... // a XOR b XOR c, assuming a, b, and c are bool
if (static_cast<bool>(a) != static_cast<bool>(b) != static_cast<bool>(c)) ... // a XOR b XOR c, for any type that can be converted to bool
if (!!a != !!b != !!c) // a XOR b XOR c, for any type that can be converted to bool
#+end_src

** Bit Manipulation
In some storage-intensive cases, maybe need bit manipulation. So i skip it.

* Scope, Duration, and Linkage

** Compound statements
Keep the nesting level of your functions to 3 or less. If your function has a need for more nested levels, consider refactoring your function into sub-functions.

** Namespace
In general, you should avoid deeply nested namespaces (more than 3 levels).

alias: namespace Active = Foo::Goo;

** Local variable
Local variable have no linkage.

Define variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables.

** Global variable
Prefer defining global variables inside a namespace rather than in the global namespace.

Consider using a “g” or “g_” prefix when naming global variables (especially those defined in the global namespace), to help differentiate them from local variables and function parameters.

** variable shadow
Avoid variable shadowing.

** Internal Linkage
Give identifiers internal linkage when you have an explicit reason to disallow access from other files.

Consider giving all identifiers you don’t want accessible to other files internal linkage (use an unnamed namespace for this).

** External Linkage
If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you’re trying to make a forward declaration for the variable.

Although constexpr variables can be given external linkage via the extern keyword, they can not be forward declared as constexpr. This is because the compiler needs to know the value of the constexpr variable (at compile time). If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.

However, you can forward declare a constexpr variable as const, which the compiler will treat as a runtime const. This isn’t particularly useful.

** Non-const global variable are evil
Use local variables instead of global variables whenever possible.

Avoid initializing objects with static duration using other objects with static duration from a different translation unit.

Dynamic initialization of global variables is also susceptible to initialization order issues and should be avoided whenever possible.

** Protecting yourself from global destruction
First, prefix all non-namespaced global variables with “g” or “g_”, or better yet, put them in a namespace, to reduce the chance of naming collisions.

Second, instead of allowing direct access to the global variable, it’s a better practice to “encapsulate” the variable. Make sure the variable can only be accessed from within the file it’s declared in, e.g. by making the variable static or const, then provide external global “access functions” to work with the variable. These functions can ensure proper usage is maintained (e.g. do input validation, range checking, etc…). Also, if you ever decide to change the underlying implementation (e.g. move from one database to another), you only have to update the access functions instead of every piece of code that uses the global variable directly.

Third, when writing an otherwise standalone function that uses the global variable, don’t use the variable directly in your function body. Pass it in as an argument instead. That way, if your function ever needs to use a different value for some circumstance, you can simply vary the argument. This helps maintain modularity.

#+begin_src cpp :main no
#include <iostream>

namespace constants
{
    constexpr double gravity { 9.8 };
}

// This function can calculate the instant velocity for any gravity value (more useful)
double instantVelocity(int time, double gravity)
{
    return gravity * time;
}

int main()
{
    std::cout << instantVelocity(5, constants::gravity) << '\n'; // pass our constant to the function as a parameter

    return 0;
}
#+end_src

** Share global constant across multiple files
If you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file.

inline implicitly extern;

** Static local variables
Using the static keyword on a local variable changes its duration from automatic duration to static duration. This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). As a result, the static variable will retain its value even after it goes out of scope!

Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.

A static local variable has block scope like a local variable, but its lifetime is until the end of the program like a global variable.

Static local variables can be used when a function needs a persistent object that is not directly accessible outside of the function.

Const static local variables are generally okay to use.

Non-const static local variables should generally be avoided. If you do use them, ensure the variable never needs to be reset, and isn’t used to alter program flow.

** Scope, duration, linkage summary
| Type                                     | Example                         | Scope  | Duration  | Linkage  | Notes                        |
| Local variable                           | int x;                          | Block  | Automatic | None     |                              |
| Static local variable                    | static int s_x;                 | Block  | Static    | None     |                              |
| Dynamic local variable                   | int* x { new int{} };           | Block  | Dynamic   | None     |                              |
| Function parameter                       | void foo(int x)                 | Block  | Automatic | None     |                              |
| Internal non-const global variable       | static int g_x;                 | Global | Static    | Internal | Initialized or uninitialized |
| External non-const global variable       | int g_x;                        | Global | Static    | External | Initialized or uninitialized |
| Inline non-const global variable (C++17) | inline int g_x;                 | Global | Static    | External | Initialized or uninitialized |
| Internal constant global variable        | constexpr int g_x { 1 };        | Global | Static    | Internal | Must be initialized          |
| External constant global variable        | extern const int g_x { 1 };     | Global | Static    | External | Must be initialized          |
| Inline constant global variable (C++17)  | inline constexpr int g_x { 1 }; | Global | Static    | External | Must be initialized          |

*** Forward declaration summary
| Type                                      | Example                   | Notes                                             |
| Function forward declaration              | void foo(int x);          | Prototype only, no function body                  |
| Non-constant variable forward declaration | extern int g_x;           | Must be uninitialized                             |
| Const variable forward declaration        | extern const int g_x;     | Must be uninitialized                             |
| Constexpr variable forward declaration    | extern constexpr int g_x; | Not allowed, constexpr cannot be forward declared |

*** storage class specifier
| Specifier    | Meaning                                                                    | Note                |
| extern       | static (or thread_local) storage duration and external linkage             |                     |
| static       | static (or thread_local) storage duration and internal linkage             |                     |
| thread_local | thread storage duration                                                    |                     |
| mutable      | object allowed to be modified even if containing class is const            |                     |
| auto         | automatic storage duration                                                 | Deprecated in C++11 |
| register     | automatic storage duration and hint to the compiler to place in a register | Deprecated in C++17 |

** Using declarations and using directives
Avoid using-declarations in header files.

Prefer explicit namespace qualifiers over using-statements. Avoid using-directives altogether (except using namespace std::literals). Using-declarations are okay to use in .cpp files, after the #includes.

** Unnamed namespace and inline namespace
*** unname namespace
Prefer unnamed namespaces when you have content you want to keep local to a translation unit.

Avoid unnamed namespaces in header files.
*** Inline namespace
#+begin_src cpp
#include <iostream>

inline namespace V1 // declare an inline namespace named V1
{
    void doSomething()
    {
        std::cout << "V1\n";
    }
}

namespace V2 // declare a normal namespace named V2
{
    void doSomething()
    {
        std::cout << "V2\n";
    }
}

int main()
{
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()

    doSomething(); // calls the inline version of doSomething() (which is V1)

    return 0;
}
#+end_src
*** Mix unname and inline
#+begin_src cpp
#include <iostream>

namespace V1 // declare a normal namespace named V1
{
    void doSomething()
    {
        std::cout << "V1\n";
    }
}

inline namespace V2 // declare an inline namespace named V2
{
    namespace // unnamed namespace
    {
        void doSomething() // has internal linkage
        {
            std::cout << "V2\n";
        }

    }
}

int main()
{
    V1::doSomething(); // calls the V1 version of doSomething()
    V2::doSomething(); // calls the V2 version of doSomething()

    doSomething(); // calls the inline version of doSomething() (which is V2)

    return 0;
}
#+end_src
* Control Flow
** Constexpr if statements
Favor constexpr if statements over non-constexpr if statements when the conditional is a constant expression.
** Switch statement basics
Switch type only allow for integral (or enumerated) types.

Place the default case last in the switch block.

Use the [​[fallthrough]] attribute (along with a null statement) to indicate intentional fallthrough.
*** Labels do not define a new scope
#+begin_src cpp
switch (1)
{
case 1: // does not create an implicit block
    foo(); // this is part of the switch scope, not an implicit block to case 1
    break; // this is part of the switch scope, not an implicit block to case 1
default:
    std::cout << "default case\n";
    break;
}
#+end_src
*** Variable declaration and initialization inside case statements
#+begin_src cpp
switch (1)
{
    int a; // okay: definition is allowed before the case labels
    int b{ 5 }; // illegal: initialization is not allowed before the case labels

case 1:
    int y; // okay but bad practice: definition is allowed within a case
    y = 4; // okay: assignment is allowed
    break;

case 2:
    int z{ 4 }; // illegal: initialization is not allowed if subsequent cases exist
    y = 5; // okay: y was declared above, so we can use it here too
    break;

case 3:
    break;
}
#+end_src

If defining variables used in a case statement, do so in a block inside the case.
#+begin_src cpp
switch (1)
{
case 1:
{ // note addition of explicit block here
    int x{ 4 }; // okay, variables can be initialized inside a block inside a case
    std::cout << x;
    break;
}

default:
    std::cout << "default case\n";
    break;
}
#+end_src
** Goto Statement
Statement labels must be associated with a statement.

Avoid goto statements (unless the alternatives are significantly worse for code readability).
** Introduction to loops and while statements
Favor while(true) for intentional infinite loops.

Integral loop variables should generally be a signed integral type.
** Do while
Favor while loops over do-while when given an equal choice.
** For loop
Avoid operator!= when doing numeric comparisons in the for-loop condition. Prefer operator< or operator<= where possible.

Defining multiple variables (in the init-statement) and using the comma operator (in the end-expression) is acceptable inside a for-statement.

Variables used only inside a loop should be defined inside the scope of the loop.

Prefer for-loops over while-loops when there is an obvious loop variable.
Prefer while-loops over for-loops when there is no obvious loop variable.

#+begin_src cpp
for (;;)
    statement;
// equivalent to, but prefer latter
while (true)
    statement;
#+end_src
** Break and continue
Use break and continue when they simplify your loop logic.
Use early returns when they simplify your function’s logic.
** Halt
std::exit is called implicitly when main() returns.
The std::exit() function does not clean up local variables in the current function or up the call stack.

std::atexit
#+begin_src cpp :main no
#include <cstdlib> // for std::exit()
#include <iostream>

void cleanup()
{
    // code here to do any kind of cleanup required
    std::cout << "cleanup!\n";
}

int main()
{
    // register cleanup() to be called automatically when std::exit() is called
    std::atexit(cleanup); // note: we use cleanup rather than cleanup() since we're not making a function call to cleanup() right now

    std::cout << 1 << '\n';

    std::exit(0); // terminate and return status code 0 to operating system

    // The following statements never execute
    std::cout << 2 << '\n';

    return 0;
}
#+end_src
In multi-threaded programs, calling std::exit() can cause your program to crash (because the thread calling std::exit() will cleanup static objects that may still be accessed by other threads). For this reason, C++ has introduced another pair of functions that work similarly to std::exit() and std::atexit() called std::quick_exit() and std::at_quick_exit(). std::quick_exit() terminates the program normally, but does not clean up static objects, and may or may not do other types of cleanup. std::at_quick_exit() performs the same role as std::atexit() for programs terminated with std::quick_exit().

Only use a halt if there is no safe or reasonable way to return normally from the main function. If you haven’t disabled exceptions, prefer using exceptions for handling errors safely.
** Generating random numbers using Mersenne Twister
*** Seeding with the system clock
#+begin_src cpp :main no
#include <iostream>
#include <random> // for std::mt19937
#include <chrono> // for std::chrono

int main()
{
	// Seed our Mersenne Twister using steady_clock
	std::mt19937 mt{ static_cast<std::mt19937::result_type>(
		std::chrono::steady_clock::now().time_since_epoch().count()
		) };

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
#+end_src
*** Seeding with the random device
std::random_device{} creates a value-initialized temporary object of type std::random_device. The () then calls operator() on that temporary object, which returns a randomized value (which we use as an initializer for our Mersenne Twister)

#+begin_src cpp
#include <iostream>
#include <random>

int main()
{
	std::random_device rd{};
	std::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; // get 8 integers of random numbers from std::random_device for our seed
	std::mt19937 mt{ ss }; // initialize our Mersenne Twister with the std::seed_seq

	// Create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };

	// Print a bunch of random numbers
	for (int count{ 1 }; count <= 40; ++count)
	{
		std::cout << die6(mt) << '\t'; // generate a roll of the die here

		// If we've printed 10 numbers, start a new row
		if (count % 10 == 0)
			std::cout << '\n';
	}

	return 0;
}
#+end_src

Only seed a given pseudo-random number generator once, and do not reseed it.
** Global random numbers (Random.h)
random.h
#+begin_src cpp :main no
#ifndef RANDOM_MT_H
#define RANDOM_MT_H

#include <chrono>
#include <random>

// This header-only Random namespace implements a self-seeding Mersenne Twister.
// Requires C++17 or newer.
// It can be #included into as many code files as needed (The inline keyword avoids ODR violations)
// Freely redistributable, courtesy of learncpp.com (https://www.learncpp.com/cpp-tutorial/global-random-numbers-random-h/)
namespace Random
{
	// Returns a seeded Mersenne Twister
	// Note: we'd prefer to return a std::seed_seq (to initialize a std::mt19937), but std::seed can't be copied, so it can't be returned by value.
	// Instead, we'll create a std::mt19937, seed it, and then return the std::mt19937 (which can be copied).
	inline std::mt19937 generate()
	{
		std::random_device rd{};

		// Create seed_seq with clock and 7 random numbers from std::random_device
		std::seed_seq ss{
			static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),
				rd(), rd(), rd(), rd(), rd(), rd(), rd() };

		return std::mt19937{ ss };
	}

	// Here's our global std::mt19937 object.
	// The inline keyword means we only have one global instance for our whole program.
	inline std::mt19937 mt{ generate() }; // generates a seeded std::mt19937 and copies it into our global object

	// Generate a random int between [min, max] (inclusive)
	inline int get(int min, int max)
	{
		return std::uniform_int_distribution{min, max}(mt);
	}

	// The following function templates can be used to generate random numbers
	// when min and/or max are not type int
	// See https://www.learncpp.com/cpp-tutorial/function-template-instantiation/
	// You can ignore these if you don't understand them

	// Generate a random value between [min, max] (inclusive)
	// * min and max have same type
	// * Return value has same type as min and max
	// * Supported types:
	// *    short, int, long, long long
	// *    unsigned short, unsigned int, unsigned long, or unsigned long long
	// Sample call: Random::get(1L, 6L);             // returns long
	// Sample call: Random::get(1u, 6u);             // returns unsigned int
	template <typename T>
	T get(T min, T max)
	{
		return std::uniform_int_distribution<T>{min, max}(mt);
	}

	// Generate a random value between [min, max] (inclusive)
	// * min and max can have different types
	// * Must explicitly specify return type as template type argument
	// * min and max will be converted to the return type
	// Sample call: Random::get<std::size_t>(0, 6);  // returns std::size_t
	// Sample call: Random::get<std::size_t>(0, 6u); // returns std::size_t
	// Sample call: Random::get<std::int>(0, 6u);    // returns int
	template <typename R, typename S, typename T>
	R get(S min, T max)
	{
		return get<R>(static_cast<R>(min), static_cast<R>(max));
	}
}

#endif
#+end_src

main.cpp
#+begin_src cpp :main no
#include "Random.h" // defines Random::mt, Random::get(), and Random::generate()
#include <cstddef> // for std::size_t
#include <iostream>

int main()
{
	// We can use Random::get() to generate random numbers

	std::cout << Random::get(1, 6) << '\n';   // returns int between 1 and 6
	std::cout << Random::get(1u, 6u) << '\n'; // returns unsigned int between 1 and 6

	// The following uses a template type argument
	// See https://www.learncpp.com/cpp-tutorial/function-template-instantiation/
	std::cout << Random::get<std::size_t>(1, 6u) << '\n'; // returns std::size_t between 1 and 6

	// We can access Random::mt directly if we have our own distribution

	// Let's create a reusable random number generator that generates uniform numbers between 1 and 6
	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };
	for (int count{ 1 }; count <= 10; ++count)
	{
		std::cout << die6(Random::mt) << '\t'; // generate a roll of the die here
	}

	std::cout << '\n';

	return 0;
}
#+end_src
* Error Detection and Handling
** Code Coverage
Aim for 100% branch coverage of your code.

Loop coverage (informally called the 0, 1, 2 test) says that if you have a loop in your code, you should ensure it works properly when it iterates 0 times, 1 time, and 2 times.

*** Testing different categories of input
For integers, make sure you’ve considered how your function handles negative values, zero, and positive values. You should also check for overflow if that’s relevant.

For floating point numbers, make sure you’ve considered how your function handles values that have precision issues (values that are slightly larger or smaller than expected). Good double type values to test with are 0.1 and -0.1 (to test numbers that are slightly larger than expected) and 0.6 and -0.6 (to test numbers that are slightly smaller than expected).

For strings, make sure you’ve considered how your function handles an empty string, an alphanumeric string, strings that have whitespace (leading, trailing, and inner), and strings that are all whitespace.

If your function takes a pointer, don’t forget to test nullptr as well (don’t worry if this doesn’t make sense, we haven’t covered it yet).

*** std::cout vs std::cerr vs logging
Use std::cout for all conventional, user-facing text.

For an interactive program, use std::cout for normal user-facing error messages (e.g. “Your input was invalid”). Use std::cerr or a logfile for status and diagnostic information that may be helpful for diagnosing issues but probably isn’t interesting for normal users. This can include technical warnings and errors (e.g. bad input to function x), status updates (e.g. successfully opened file x, failed to connect to internet service x), percentage completion of long tasks (e.g. encoding 50% complete), etc…

For a non-interactive program (tool or service), use std::cerr for error output only (e.g. could not open file x). This allows errors to be displayed or parsed separately from normal output.

For any application type that is transactional in nature (e.g. one that processes specific events, such as an interactive web browser or non-interactive web server), use a logfile to produce a transactional log of events that can be reviewed later. This can include outputting to the logfile which file is being processed, updates on the percentage complete, timestamps of when it started certain stages of computing, warning and error messages, etc…

*** std::cin handling invalid input
#+begin_src cpp
#include <cstdlib> // for std::exit
#include <iostream>
#include <limits> // for std::numeric_limits

void ignoreLine()
{
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
}

// returns true if extraction failed, false otherwise
bool clearFailedExtraction()
{
    // Check for failed extraction
    if (!std::cin) // If the previous extraction failed
    {
        if (std::cin.eof()) // If the stream was closed
        {
            exit(0); // Shut down the program now
        }

        // Let's handle the failure
        std::cin.clear(); // Put us back in 'normal' operation mode
        ignoreLine();     // And remove the bad input

        return true;
    }

    return false;
}

double getDouble()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter a decimal number: ";
        double x{};
        std::cin >> x;

        if (clearFailedExtraction())
        {
            std::cout << "Oops, that input is invalid.  Please try again.\n";
            continue;
        }

        ignoreLine(); // Remove any extraneous input
        return x;     // Return the value we extracted
    }
}

char getOperator()
{
    while (true) // Loop until user enters a valid input
    {
        std::cout << "Enter one of the following: +, -, *, or /: ";
        char operation{};
        std::cin >> operation;

        if (!clearFailedExtraction()) // we'll handle error messaging if extraction failed below
             ignoreLine(); // remove any extraneous input (only if extraction succeded)

        // Check whether the user entered meaningful input
        switch (operation)
        {
        case '+':
        case '-':
        case '*':
        case '/':
            return operation; // Return the entered char to the caller
        default: // Otherwise tell the user what went wrong
            std::cout << "Oops, that input is invalid.  Please try again.\n";
        }
    }
}

void printResult(double x, char operation, double y)
{
    std::cout << x << ' ' << operation << ' ' << y << " is ";

    switch (operation)
    {
    case '+':
        std::cout << x + y << '\n';
        return;
    case '-':
        std::cout << x - y << '\n';
        return;
    case '*':
        std::cout << x * y << '\n';
        return;
    case '/':
        if (y == 0.0)
            break;

        std::cout << x / y << '\n';
        return;
    }

    std::cout << "???";  // Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program
}

int main()
{
    double x{ getDouble() };
    char operation{ getOperator() };
    double y{ getDouble() };

    // Handle division by 0
    while (operation == '/' && y == 0.0)
    {
        std::cout << "The denominator cannot be zero.  Try again.\n";
        y = getDouble();
    }

    printResult(x, operation, y);

    return 0;
}
#+end_src

*** Assert and static_assert
Use assertions to document cases that should be logically impossible.

If the macro NDEBUG is defined, the assert macro gets disabled.

#+begin_src cpp
assert(moved && "Need to handle case where student was just moved to another classroom");
#+end_src

A static_assert is an assertion that is checked at compile-time rather than at runtime, with a failing static_assert causing a compile error. Unlike assert, which is declared in the <cassert> header, static_assert is a keyword, so no header needs to be included to use it.
* Type Conversion, Type Aliases, and Type Deduction
** Narrowing conversions
From a floating point type to an integral type.
From a floating point type to a narrower or lesser ranked floating point type, unless the value being converted is constexpr and is in range of the destination type (even if the destination type doesn’t have the precision to store all the significant digits of the number).
From an integral to a floating point type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.
From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type. This covers both wider to narrower integral conversions, as well as integral sign conversions (signed to unsigned, or vice-versa).

If you need to perform a narrowing conversion, use static_cast to convert it into an explicit conversion.
Some constexpr conversions aren’t considered narrowing.

** Arithmetic conversions
The usual arithmetic conversion rules are somewhat complex, so we’ll simplify a bit. The compiler has a ranked list of types that looks something like this:
*** The usual arithmetic conversion rules
1. long double (highest rank)
2. double
3. float
4. long long
5. long
6. int (lowest rank)

**** sign and unsigned
If the rank of the unsigned operand is greater than the rank of the signed operand, the signed operand is converted to the type of the unsigned operand.
If the type of the signed operand can represent all the values of the type of the unsigned operand, the type of the unsigned operand is converted to the type of the signed operand.
Otherwise both operands are converted to the corresponding unsigned type of the signed operand.
** Explicit type conversion (casting) and static_cast
Avoid using C-style casts.
Avoid const casts and reinterpret casts unless you have a very good reason to use them.
** Typedefs and type aliases
#+begin_src cpp
using Distance = double; // define Distance as an alias for type double
#+end_src
Name your type aliases starting with a capital letter and do not use a suffix (unless you have a specific reason to do otherwise).

Prefer type aliases over typedefs.

Use type aliases judiciously, when they provide a clear benefit to code readability or code maintenance.
** Type deduction for objects using the auto keyword
Use type deduction for your variables when the type of the object doesn’t matter.

Favor an explicit type when you require a specific type that differs from the type of the initializer, or when your object is used in a context where making the type obvious is useful.
*** Type deduction drops const / constexpr qualifiers
#+begin_src cpp
int main()
{
    const int x { 5 };  // x has type const int (compile-time const)
    auto y { x };       // y will be type int (const is dropped)

    constexpr auto z { x }; // z will be type constexpr int (constexpr is reapplied)

    return 0;
}
#+end_src
*** Type deduction for string literals
#+begin_src cpp
#include <string>
#include <string_view>

int main()
{
    using namespace std::literals; // easiest way to access the s and sv suffixes

    auto s { "Hello, world" }; // s will be type const char*, not std::string
    auto s1 { "goo"s };  // "goo"s is a std::string literal, so s1 will be deduced as a std::string
    auto s2 { "moo"sv }; // "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view

    return 0;
}
#+end_src
** Type deduction for functions
Favor explicit return types over function return type deduction for normal functions.

Auto can also be used as a function return type to have the compiler infer the function’s return type from the function’s return statements, though this should be avoided for normal functions. Auto is used as part of the trailing return syntax.
* Function Overloading and Function Templates
** Function overload differentiation
| Function property    | Used for differentiation | Notes                                                                                        |
|----------------------+--------------------------+----------------------------------------------------------------------------------------------|
| Number of parameters | Yes                      |                                                                                              |
| Type of parameters   | Yes                      | Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses. |
| Return type          | No                       |                                                                                              |
** Deleting all non-matching overloads
= delete means “I forbid this”, not “this doesn’t exist”.
#+begin_src cpp
#include <iostream>

// This function will take precedence for arguments of type int
void printInt(int x)
{
    std::cout << x << '\n';
}

// This function template will take precedence for arguments of other types
// Since this function template is deleted, calls to it will halt compilation
template <typename T>
void printInt(T x) = delete;

int main()
{
    printInt(97);   // okay
    printInt('a');  // compile error
    printInt(true); // compile error

    return 0;
}
#+end_src
** Default arguments
If a parameter is given a default argument, all subsequent parameters (to the right) must also be given default arguments.
If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.
** Function templates
Templates can work with types that didn’t even exist when the template was written. This helps make template code both flexible and future proof!

Use a single capital letter starting with T (e.g. T, U, V, etc…) to name type template parameters that are used in trivial or obvious ways and represent “any reasonable type”.

If the type template parameter has a non-obvious usage or specific requirements that must be met, then a more descriptive name is warranted. (e.g. Allocator or TAllocator).
** function template instantiation
Favor the normal function call syntax when making calls to a function instantiated from a function template (unless you need the function template version to be preferred over a matching non-template function).

The compiler will instantiate and compile function templates that do not make sense semantically as long as they are syntactically valid. It is your responsibility to make sure you are calling such function templates with arguments that make sense.

Use function templates to write generic code that can work with a wide variety of types whenever you have the need.

Templates that are needed in multiple files should be defined in a header file, and then #included wherever needed. This allows the compiler to see the full template definition and instantiate the template when needed.
** Function templates with multiple template types
#+begin_src cpp :main no
#include <iostream>

template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}

int main()
{
    std::cout << max(2, 3.5) << '\n';

    return 0;
}
#+end_src
*** Abbreviated function templates 
#+begin_src cpp
auto max(auto x, auto y)
{
    return (x < y) ? y : x;
}
#+end_src
is shorthand in C++20 for the following:
#+begin_src cpp
template <typename T, typename U>
auto max(T x, U y)
{
    return (x < y) ? y : x;
}
#+end_src
Feel free to use abbreviated function templates with a single auto parameter, or where each auto parameter should be an independent type (and your language standard is set to C++20 or newer).
** Non-type template parameters
A non-type template parameter can be any of the following types:

- An integral type
- An enumeration type
- std::nullptr_t
- A floating point type (since C++20)
- A pointer or reference to an object
- A pointer or reference to a function
- A pointer or reference to a member function
- A literal class type (since C++20)
*** example
#+begin_src cpp :main no
#include <iostream>

template <int N> // declare a non-type template parameter of type int named N
void print()
{
    std::cout << N << '\n'; // use value of N here
}

int main()
{
    print<5>(); // 5 is our non-type template argument

    return 0;
}
#+end_src
Use N as the name of an int non-type template parameter.

Non-type template parameters are used primarily when we need to pass constexpr values to functions (or class types) so they can be used in contexts that require a constant expression.
* Compound Types: References and Pointers
** Lvalue and Rvalue
Lvalue expressions evaluate to an identifiable object.
Rvalue expressions evaluate to a value.
** lvalue reference
When defining a reference, place the ampersand next to the type (not the reference variable’s name).
References can’t be reseated (changed to refer to another object)


** lvalue reference to const
Favor lvalue references to const over lvalue references to non-const unless you need to modify the object being referenced.

Lvalue references can only bind to modifiable lvalues.

Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.
*** Initializing an lvalue reference to const with a value of a different type
If you try to bind a const lvalue reference to a value of a different type, the compiler will create a temporary object of the same type as the reference, initialize it using the value, and then bind the reference to the temporary.

Lifetime extension only works when a const reference is directly bound to a temporary. Temporaries returned from a function (even ones returned by const reference) are not eligible for lifetime extension.
*** constexpr lvalue reference
When applied to a reference, constexpr allows the reference to be used in a constant expression. Constexpr references have a particular limitation: they can only be bound to objects with static duration (either globals or static locals). This is because the compiler knows where static objects will be instantiated in memory, so it can treat that address as a compile-time constant.

#+begin_src cpp :main no
int g_x { 5 };

int main()
{
    [[maybe_unused]] constexpr int& ref1 { g_x }; // ok, can bind to global

    static int s_x { 6 };
    [[maybe_unused]] constexpr int& ref2 { s_x }; // ok, can bind to static local

    int x { 6 };
    [[maybe_unused]] constexpr int& ref3 { x }; // compile error: can't bind to non-static object

    return 0;
}
#+end_src
** pass by const lvalue reference
Favor passing by const reference over passing by non-const reference unless you have a specific reason to do otherwise (e.g. the function needs to change the value of an argument).
*** When to pass by (const) reference
Prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy. If you’re not sure whether an object is cheap or expensive to copy, favor pass by const reference.

As a rule of thumb, pass fundamental types by value, and class (or struct) types by const reference.

Other common types to pass by value: enumerated types and std::string_view.
Other common types to pass by (const) reference: std::string, std::array, and std::vector.
** Pointer
When declaring a pointer type, place the asterisk next to the type name.
Always initialize your pointers.

#+begin_src cpp
int* ptr1, ptr2;   // incorrect: ptr1 is a pointer to an int, but ptr2 is just a plain int!
int* ptr3, * ptr4; // correct: ptr3 and ptr4 are both pointers to an int
#+end_src
*** Pointer vs Reference
- References must be initialized, pointers are not required to be initialized (but should be).
- References are not objects, pointers are.
- References can not be reseated (changed to reference something else), pointers can change what they are pointing at.
- References must always be bound to an object, pointers can point to nothing (we’ll see an example of this in the next lesson).
- References are “safe” (outside of dangling references), pointers are inherently dangerous (we’ll also discuss this in the next lesson).
** Null pointer
Value initialize your pointers (to be null pointers) if you are not initializing them with the address of a valid object.
Use nullptr when you need a null pointer literal for initialization, assignment, or passing a null pointer to a function.

#+begin_src cpp :main no
#include <iostream>

int main()
{
    int x { 5 };
    int* ptr { &x };

    // pointers convert to Boolean false if they are null, and Boolean true if they are non-null
    if (ptr) // implicit conversion to Boolean
        std::cout << "ptr is non-null\n";
    else
        std::cout << "ptr is null\n";

    int* nullPtr {};
    std::cout << "nullPtr is " << (nullPtr ? "non-null\n" : "null\n"); // implicit conversion to Boolean

    return 0;
}
#+end_src

Conditionals can only be used to differentiate null pointers from non-null pointers. There is no convenient way to determine whether a non-null pointer is pointing to a valid object or dangling (pointing to an invalid object).

A pointer should either hold the address of a valid object, or be set to nullptr. That way we only need to test pointers for null, and can assume any non-null pointer is valid.

When an object is destroyed, any pointers to the destroyed object will be left dangling (they will not be automatically set to nullptr). It is your responsibility to detect these cases and ensure those pointers are subsequently set to nullptr.

Favor references over pointers unless the additional capabilities provided by pointers are needed.
** Pointer and const
#+begin_src cpp :main no
int main()
{
    int v{ 5 };

    int* ptr0 { &v };             // points to an "int" but is not const itself, so this is a normal pointer.
    const int* ptr1 { &v };       // points to a "const int" but is not const itself, so this is a pointer to a const value.
    int* const ptr2 { &v };       // points to an "int" and is const itself, so this is a const pointer (to a non-const value).
    const int* const ptr3 { &v }; // points to a "const int" and is const itself, so this is a const pointer to a const value.

    // if the const is on the left side of the *, the const belongs to the value
    // if the const is on the right side of the *, the const belongs to the pointer

    return 0;
}
#+end_src
** pass by address
Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.

nullptr has type std::nullptr_t (defined in header <cstddef>).
*** Pass by address… by reference
A function to change what a pointer argument points to.
#+begin_src cpp :main no
#include <iostream>

void nullify(int*& refptr) // refptr is now a reference to a pointer
{
    refptr = nullptr; // Make the function parameter a null pointer
}

int main()
{
    int x{ 5 };
    int* ptr{ &x }; // ptr points to x

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");

    nullify(ptr);

    std::cout << "ptr is " << (ptr ? "non-null\n" : "null\n");
    return 0;
}
#+end_src
** return by ref or address
Avoid returning references to non-const local static variables.
Prefer return by reference over return by address unless the ability to return “no object” (using nullptr) is important.
** in and out parameters
Avoid out-parameters (except in the rare case where no better options exist).

Prefer pass by reference for non-optional out-parameters.
** type dedution with pointers references and const
If you want a const pointer, pointer to const, or const pointer to const, reapply the const qualifier(s) even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.
If you want a const reference, reapply the const qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.
*** Top-level const and low-level const
A top-level const is a const qualifier that applies to an object itself. For example:
#+begin_src cpp
const int x;    // this const applies to x, so it is top-level
int* const ptr; // this const applies to ptr, so it is top-level
#+end_src

In contrast, a low-level const is a const qualifier that applies to the object being referenced or pointed to:
#+begin_src cpp
const int& ref; // this const applies to the object being referenced, so it is low-level
const int* ptr; // this const applies to the object being pointed to, so it is low-level
#+end_src

A reference to a const value is always a low-level const. A pointer can have a top-level, low-level, or both kinds of const:
#+begin_src cpp
const int* const ptr; // the left const is low-level, the right const is top-level
#+end_src

When we say that type deduction drops const qualifiers, it only drops top-level consts. Low-level consts are not dropped.
** std::optional
| Behavior           | Pointer                              | std::optional                              |
|--------------------+--------------------------------------+--------------------------------------------|
| Hold no value      | initialize/assign {} or std::nullptr | initialize/assign {} or std::nullopt       |
| Hold a value       | initialize/assign an address         | initialize/assign a value                  |
| Check if has value | implicit conversion to bool          | implicit conversion to bool or has_value() |
| Get value          | dereference                          | dereference or value()                     |
Return a std::optional (instead of a sentinel value) for functions that may fail, unless your function needs to return additional information about why it failed.
std::expected (introduced in C++23) is designed to handle the case where a function can return either an expected value or an unexpected error code.

Prefer std::optional for optional return types.

Prefer function overloading for optional function parameters (when possible). Otherwise, use std::optional<T> for optional arguments when T would normally be passed by value. Favor const T* when T is expensive to copy.

* Next
https://www.learncpp.com/cpp-tutorial/introduction-to-program-defined-user-defined-types/
