* Basic
** Initialization
https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/

Prefer list or value initialization.

#+begin_src cpp
int a;         // no initializer                            (default initialization)
int b = 5;     // initial value after equals sign           (copy initialization)
int c( 6 );    // initial value in parenthesis              (direct initialization)

// List initialization methods                              (C++11) (preferred)
int d { 7 };   // initial value in braces                   (direct list initialization)
int e = { 8 }; // initial value in braces after equals sign (copy list initialization)
int f {};      // initializer is empty braces               (value initialization)
#+end_src

*** multiple init
#+begin_src cpp
int a = 5, b = 6;          // copy initialization
int c( 7 ), d( 8 );        // direct initialization
int e { 9 }, f { 10 };     // direct brace initialization
int g = { 9 }, h = { 10 }; // copy brace initialization
int i {}, j {};            // value initialization
#+end_src

use [[maybe_unused]​] attribute to avoid error, via abbrev.

** iostream
Prefer \n over std::endl when outputting text to the console.


* Function and File
** Return value
If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.
#+begin_src cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
#+end_src

** Comment unused function parameter
When a function parameter exists but is not used in the body of the function, do not give it a name. You can optionally put a name inside a comment.
#+begin_src cpp
void doSomething(int /*count*/)
{
}
#+end_src

** Define variable
Define your local variables as close to their first use as reasonable.

** Preprocessor
The entire process of preprocessing, compiling, and linking is called translation.

Preprocessor doesn’t understand C++ concepts.

Directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one file do not have any impact on other files (unless they are #included into another file).


** Header
Source files should #include their paired header file (if one exists).

Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.

Use the standard library header files without the .h extension. User-defined headers should still use a .h extension.

Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

*** #include order
1. The paired header file
2. Other headers from your project
3. 3rd party library headers
4. Standard library headers

That way, if one of your user-defined headers is missing an #include for a 3rd party library or standard library header, it’s more likely to cause a compile error so you can fix it.

** Header Guard
Beware two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\config.h and directoryB\config.h).

** Design and Implementation

*** Design step
**** Define goal
It is often useful to express this as a user-facing outcome. For example:

1. Allow the user to organize a list of names and associated phone numbers.
2. Generate randomized dungeons that will produce interesting looking caverns.
3. Generate a list of stock recommendations for stocks that have high dividends.
4. Model how long it takes for a ball dropped off a tower to hit the ground.
**** Define requirements
Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc…), as well as the capabilities that the program must exhibit in order to meet the users’ needs. Note that your requirements should similarly be focused on the “what”, not the “how”. For example:

- Phone numbers should be saved, so they can be recalled later.
- The randomized dungeon should always contain a way to get from the entrance to an exit.
- The stock recommendations should leverage historical pricing data.
- The user should be able to enter the height of the tower.
- We need a testable version within 7 days.
- The program should produce results within 10 seconds of the user submitting their request.
- The program should crash in less than 0.1% of user sessions.
**** Define your tools, targets, and backup plan
- Defining what target architecture and/or OS your program will run on.
- Determining what set of tools you will be using.
- Determining whether you will write your program alone or as part of a team.
- Defining your testing/feedback/release strategy.
- Determining how you will back up your code.
**** Break hard problems down into easy problems
The top level task becomes main() (because it is the main problem you are trying to solve). The subitems become functions in the program.
**** Figure out the sequence of events
If we were writing a calculator, we might do things in this order:

1. Get first number from user
2. Get mathematical operation from user
3. Get second number from user
4. Calculate result
5. Print result

At this point, we’re ready for implementation.

*** Implementation
**** Outlining your main function
#+begin_src cpp
int main()
{
    // Get first number from user
//    getUserInput();

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Implement each function
1. Define the function prototype (inputs and outputs)
2. Write the function
3. Test the function
#+begin_src cpp
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
#+end_src
**** Final testing
Once your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.

*** Words of advice when writing programs

**** Keep your programs simple to start
Often new programmers have a grand vision for all the things they want their program to do. “I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon”. If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress. Instead, make your first goal as simple as possible, something that is definitely within your reach. For example, “I want to be able to display a 2-dimensional field on the screen”.



**** Add features over time
Once you have your simple program working and working well, then you can add features to it. For example, once you can display your field, add a character who can walk around. Once you can walk around, add walls that can impede your progress. Once you have walls, build a simple town out of them. Once you have a town, add merchants. By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.

**** Focus on one area at a time
New programmers will often write the entire program in one pass. Then when they compile it for the first time, the compiler reports hundreds of errors. This can not only be intimidating, if your code doesn’t work, it may be hard to figure out why. Instead, write a piece of code, and then compile and test it immediately. If it doesn’t work, you’ll know exactly where the problem is, and it will be easy to fix. Once you are sure that the code works, move to the next piece and repeat. It may take longer to finish writing your code, but when you are done the whole thing should work, and you won’t have to spend twice as long trying to figure out why it doesn’t.

**** Don’t invest in perfecting early code
The first draft of a feature (or program) is rarely good. Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things. If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary. Instead, get your features minimally working and then move on. As you gain confidence in your solutions, apply successive layers of polish. Don’t aim for perfect -- non-trivial programs are never perfect, and there’s always something more that could be done to improve them. Get to “good enough” and move on.



**** Optimize for maintainability, not performance
There is a famous quote (by Donald Knuth) that says “premature optimization is the root of all evil”. New programmers often spend far too much time thinking about how to micro-optimize their code (e.g. trying to figure out which of 2 statements is faster). This rarely matters. Most performance benefits come from good program structure, using the right tools and capabilities for the problem at hand, and following best practices. Additional time should be used to improve the maintainability of your code. Find redundancy and remove it. Split up long functions into shorter ones. Replace awkward or hard to use code with something better. The end result will be code that is easier to improve and optimize later (after you’ve determined where optimization is actually needed) and fewer bugs.



* Debug
** Step
1. Find the root cause of the problem (usually the line of code that’s not working).
2. Ensure you understand why the issue is occurring.
3. Determine how you’ll fix the issue.
4. Repair the issue causing the problem.
5. Retest to ensure the problem has been fixed.
6. Retest to ensure no new problems have emerged.

** Tactic

*** std::cerr instead of std::cout when debugging
cerr is unbufferd.

*** Debug with preprocessor
#+begin_src cpp
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging, or define in header file

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
#+end_src

*** Logger
Such as spdlog or plog.

** Refactor
Ideally, a function should be less than ten lines. Functions that are less than five lines are even better.

Remember that the goal here is to maximize comprehension and maintainability, not to minimize function length -- abandoning best practices or using obscure coding techniques to save a line or two doesn’t do your code any favors.

** Defensive programming
Defensive programming is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code. These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).

** unit testing
#+begin_src cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void testadd()
{
	std::cout << "This function should print: 2 0 0 -2\n";
	std::cout << add(1, 1) << ' ';
	std::cout << add(-1, 1) << ' ';
	std::cout << add(1, -1) << ' ';
	std::cout << add(-1, -1) << ' ';
}

int main()
{
	testadd();

	return 0;
}
#+end_src

* Fundamental Data Type
** Int
#+begin_src cpp
short s;      // prefer "short" instead of "short int"
int i;
long l;       // prefer "long" instead of "long int"
long long ll; // prefer "long long" instead of "long long int"
signed short ss;
signed int si;
signed long sl;
signed long long sll;
#+end_src
Prefer the shorthand types that do not use the int suffix or signed prefix.

*** Signed integer range
$-(2^(n-1))$ to $2^(n-1)-1$

If outside the range, then overflow.

*** Unsigned integer
Avoid unsigned integer.

Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.

**** when should you use unsigned numbers?
First, unsigned numbers are preferred when dealing with bit manipulation (covered in chapter O -- that’s a capital ‘o’, not a ‘0’). They are also useful when well-defined wrap-around behavior is required (useful in some algorithms like encryption and random number generation).

Second, use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing. We’ll talk more about this in the lessons on arrays and array indexing.

Also note that if you’re developing for an embedded system (e.g. an Arduino) or some other processor/memory limited context, use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.

*** fixed-width-integers and size_t

**** integer choice

***** Prefer

Prefer int when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer) and the variable is short-lived (e.g. destroyed at the end of the function). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.
Prefer std::int#_t when storing a quantity that needs a guaranteed range.
Prefer std::uint#_t when doing bit manipulation or where well-defined wrap-around behavior is required.

***** Avoid

short and long integers -- use a fixed-width type instead.
Unsigned types for holding quantities.
The 8-bit fixed-width integer types.
The fast and least fixed-width types.
Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…

**** size_t
std::size_t is an alias for an implementation-defined unsigned integral type. It is used within the standard library to represent the byte-size or length of objects.

If you use std::size_t explicitly in your code, #include one of the headers that defines std::size_t (we recommend <cstddef>).
Using sizeof does not require a header (even though it return a value whose type is std::size_t).

* Next
https://www.learncpp.com/cpp-tutorial/introduction-to-scientific-notation/
